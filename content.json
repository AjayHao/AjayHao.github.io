{"meta":{"title":"Ajay's Blog","subtitle":"","description":"Hexo theme - 3-hexo","author":"Hao Zhenjie","url":"http://ajayhao.github.io","root":"/"},"pages":[{"title":"分类","date":"2016-01-22T14:00:00.000Z","updated":"2016-01-22T14:00:00.000Z","comments":false,"path":"categories/index.html","permalink":"http://ajayhao.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2016-01-22T14:00:00.000Z","updated":"2016-01-22T14:00:00.000Z","comments":false,"path":"tags/index.html","permalink":"http://ajayhao.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2016-01-22T14:00:00.000Z","updated":"2016-01-22T14:00:00.000Z","comments":false,"path":"about/index.html","permalink":"http://ajayhao.github.io/about/index.html","excerpt":"","text":"IT科班出身，金融行业码农，由于工作之后技能点乱点，因而无稳定技术流派，已义无反顾投身开源世界 Java爱好者，近期又迷上了Python， 内心深处拒绝“成为码农”却又常常研究代码到深夜 讨厌无趣的人，更害怕自己变成一个那样的人。。 万幸已脱单。。难为妹子了orz So..Don’t Have to Try So Hard..Just relax , and share , and have FUN !!! 联系方式 Email - ajay.hao@gmail.com Github - github.com/ajayhao Weibo - weibo.com/ajayhao"},{"title":"不煽情","date":"2021-01-03T13:10:31.000Z","updated":"2021-01-03T13:10:31.000Z","comments":true,"path":"scratch/todearfx.html","permalink":"http://ajayhao.github.io/scratch/todearfx.html","excerpt":"","text":"这一篇内容留给你，标题留给我自己，免得写着写着老毛病又犯。 你一定会有很多疑问吧，之前关系那么好了，怎么突然就翻车了。 哪会有那么多莫名其妙呢，很多事情藏在心里很久了。。 生日能收到礼物，不贵却很”重”，花了心思的份量十足。 除了父母爱人之外，我何以受过这样的礼遇。后来发现，可以用很亲昵的称呼了，可以语音还可以视频了，觉得自己像多了个“亲人”，幸福感满满呀。。可现实呢，现实真是这样的么？ 尽管聊天窗口里无所忌口，摄像头的另一面笑的多么灿烂；现实生活里，我们就像陌生人，我们就是陌生人！ 回到现实，我甚至不明白是怎么走到今天的。 就我们组里名义上大家都是同事，可无论xt还是ll，你们在同一个业务系统的战壕里，实打实的战友，有建立深厚友谊的基础。 你和表哥和薛，哪怕只是某个简单业务模块的需求方和实现，也算工作交集，称得上同事。我想了很久，哪怕任何工作细项上，不曾有合作，也没有任何事情我能效劳。。具体的工作是领导的安排，我没有选择权，无论是巧合还是剧本，事实层面我与产品组是零交集了，那我们关系为什么那么好？ 是不是发现这件事成了无本之木，凭空在微信世界里能亲密无间，现实之中就解释不过去了，平时点头之交都难。 现实中扮陌生人，回到家微信又能聊到深夜。。久而久之我产生了一种无所适从，两个割裂的世界带来的，巨大的脱力感： 绿底黑字是一个世界，现实生活是另一个世界。 一个世界里每天都会有你的各种动态；另一个世界里，因为这样那样的原因，不敢留有你的任何痕迹。。这种矛盾产生的不适感越来越强烈，强烈到后来我甚至害怕你来微信，因为那段时间“微信”上的关系又特别好，我不知道我应该调节到哪个状态来回复，才更适配这个真实的世界。而且因为加班的关系，微信总是深夜来，躺在床上看着微信，常常陷入回与不回的两难，隔天到单位开pc版微信第一时间是找你的聊天窗口然后秒关，真的好尴尬。。 “你住的城市下雨了，很想问你有没有带伞。可是我忍住了，因为我怕你说没带，而我又无能为力” -- 宫崎骏我究竟是谁，微信世界里你的zj哥哥，是蝙蝠侠一样的英雄吗？可现实里呢，我已经受够了这个虚拟世界对现实世界的“反噬”了，这种裂开的感觉，我想纠正过来，如果现实世界里没有办法很快改变，那就改变虚拟世界吧。。 我之前说自己是工具人，你不认可。我相信你，并不想我成为一个聊天宝宝吧。。可回到现实，现实层面，我的存在不就是个单纯聊天工具嘛！我除了陪聊天功能，可还有其他的功能？ 我没办法帮你处理合同，帮你查问题，帮你提升见识、眼界、格局，提供任何生活必需品以外的任何有价值的资源。。聊天以外的具体工作和生活事项，一切都与我没有干系。。而且很多时候聊天本身，除了派遣了无聊寂寞，可还有哪些实质的帮助吗？ 靠几句无关痛痒的言语，可有让你的工作量变少，可有能让你怀上心心念念的宝宝，可有让你的生活品质有所提升？都没有，none at all。。自己都觉得这天聊得很可悲不是么。 聊天会产生依赖感的，改变习惯一定很痛苦，如果两个人都不坚定，那就败了。。之前败了多少次我也记不清了。可这次应该不一样，从你那天找ll吃饭的时候开始，我突然意识到。。在你的微信世界里，就聊天本身，你有更好的选择了。ll也很健谈，而且从性格的完整性上，他比我更合适做你心理上的那个“哥哥”，性格更稳重更阳光，工作上交集也更多，从现实基础的角度，他才是更适合你培养成长期的可持续交流、互助好朋友。起码有能力真正的帮你，减轻你的工作负担，让你的生活更轻松，对吧。 我觉得自己还算外向的人，却不够阳光，不知道怎么形容这种性格。直到这次B站跨年演出中冯提莫唱了“外向型自闭症患者”，真的是完美贴合。。 这不就是我么，表面外向，内在却很封闭。。这种有缺陷的性格给周遭相处的人或多或少带来了负面的影响。这两年没让你少受苦，自己也很过意不去，就像你说的，表现的像PUA。 我不想PUA你啊，不想PUA任何人，这种事在我身上没有任何幸福感，只有痛苦。可和你相处这件事情上，在现实和虚幻之间，我真的觉得一直在刻意的“两面派”，很累，太累了。。且就聊天工具的角度，我都很失败啊。。掩面摇头。。 12月中旬有一阵子实在闷的心烦，我会听《金刚经》，王菲39分钟的版本，听多了就想明白了很多事情。 一切有为法，如梦幻泡影，如露亦如电，应作如是观。 3周时间，足够养成一个新的习惯了。我也以为你已经习惯了，不曾想昨天突然的问我，还能好么？ 怎样算好，怎样算不好，回到这一年半载的任何一个时点，你可愿意？ 这一年半载的任何一个时点，结果都是一个不变的循环，不断的会在某一个节点地震一次，伤害你一次，然后带着伤痕，进入下一个循环。你想要这样？ 我想回到2年前，那时候和你虽然初识，没有那么多话聊，却也没有那么多复杂的关系和现实的负担，那时候的我们还可以约吃饭，约下班。在你眼里，我也还是个温暖和善的大哥哥。。可惜。。回不去了 所以，如果你对于这个现实有更好的办法，请告诉我，该怎么做，能怎么做？如果你也对目前的现实同样无可奈何，那至少，让我体面的从你的微信世界里消失，那些痛快的不痛快的事情，让时间刻成灰然后扬了吧，不要再给我任何伤害你的机会了。 我想做个好人，就这么简单。"}],"posts":[{"title":"Https证书生成及转换","slug":"https-certs","date":"2023-01-16T07:57:47.000Z","updated":"2023-01-16T07:57:47.000Z","comments":true,"path":"2023/01/16/https-certs/","link":"","permalink":"http://ajayhao.github.io/2023/01/16/https-certs/","excerpt":"","text":"[toc] 1.生成部分 -2.转换部分 - 转自后端老鸟：Nginx证书和Tomcat证书能相互转化吗，请看这里转换部分主流 Web 服务软件证书一般来说，主流的 Web 服务软件，通常都基于 OpenSSL 和 Java 两种基础密码库。 Tomcat、Weblogic、JBoss等Web服务软件，一般使用Java提供的密码库。通过Java Development Kit （JDK）工具包中的Keytool工具，生成Java Keystore（JKS）格式的证书文件。 Apache、Nginx等Web服务软件，一般使用OpenSSL工具提供的密码库，生成PEM、KEY、CRT等格式的证书文件。 IBM的Web服务产品，如Websphere、IBM Http Server（IHS）等，一般使用IBM产品自带的iKeyman工具，生成KDB格式的证书文件。 微软Windows Server中的Internet Information Services（IIS）服务，使用Windows自带的证书库生成PFX格式的证书文件。 判断证书文件格式您可以使用以下方法简单区分带有后缀扩展名的证书文件： .DER或.CER文件： 这样的证书文件是二进制格式，只含有证书信息，不包含私钥。 .CRT文件： 这样的证书文件可以是二进制格式，也可以是文本格式，一般均为文本格式，功能与 .DER及.CER证书文件相同。 .PEM文件： 这样的证书文件一般是文本格式，可以存放证书或私钥，或者两者都包含。 .PEM 文件如果只包含私钥，一般用.KEY文件代替。 .PFX或.P12文件： 这样的证书文件是二进制格式，同时包含证书和私钥，且一般有密码保护。 证书格式转换上面这张图很直观的说明了各种证书之间转化的流程，只要每一步转化成功其他的转化都是每一步的组合。 JKS 和 PFX 相互转化PFX格式证书文件和JKS格式证书相互转化可以使用JDK中自带的keytool工具。 #将JKS格式转换成PFX格式 keytool -importkeystore -srckeystore server.jks -destkeystore server.pfx -srcstoretype JKS -deststoretype PKCS12 #将PFX格式转换成JKS格式 keytool -importkeystore -srckeystore server.pfx -srcstoretype PKCS12 -srcstorepass {pfx-password} -destkeystore server.jks -deststoretype JKS -deststorepass {jks-password} -alias {key-alias}PFX 和 KEY&amp;CRT 相互转化PEM/KEY/CRT格式证书和PFX格式互相转换可以使用 OpenSSL工具。 #将PFX转换为PEM/KEY/CRT openssl pkcs12 -in server.pfx -nodes -out server.pem openssl rsa -in server.pem -out server.key openssl x509 -in server.pem -out server.crt此转换步骤是专用于通过Keytool工具生成私钥和CSR申请证书文件的，并且通过此方法您可以在获取到PEM格式证书公钥的情况下分离私钥。 #将PEM/KEY/CRT转换为PFX openssl pkcs12 -export -out server.pfx -inkey server.key -in server.crt","categories":[{"name":"技术","slug":"技术","permalink":"http://ajayhao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"https","slug":"https","permalink":"http://ajayhao.github.io/tags/https/"}]},{"title":"CentOS下 SCIP优化器及PySCIpypt客户端安装","slug":"pyscipopt-install","date":"2022-05-21T12:57:47.000Z","updated":"2022-05-21T12:57:47.000Z","comments":true,"path":"2022/05/21/pyscipopt-install/","link":"","permalink":"http://ajayhao.github.io/2022/05/21/pyscipopt-install/","excerpt":"","text":"没想到在Linux下安装SCIP这个开源优化器会踩到那么多的坑。。步骤含泪安装记录，希望可以帮助到更多需要的人。 文中涉及到cmake、scip及pyscipopt的版本，在实操中建议保持一致；若有偏差不保证能安装成功。。 STEP1: centos安装gcc及必要的devel组件 root用户安装gcc yum install openssl-devel -y yum install zlib-devel -y yum install gcc -y yum install gcc-c++ -y root用户安装部分devel工具包 yum install libffi-devel -y yum install gmp-devel -y yum install python3-devel -y yum install readline-devel -y yum install g++-multilib -y root用户进行include目录合并（此步骤非常重要），并赋权给执行用户 #将/usr/include目录合并到/usr/local/inlude目录下 cp -R /usr/include /usr/local/include #临时将/usr/local/include下的文件切换给执行用户（比如rhzl） chown -R rhzl:rhzl /usr/local/includeSTEP2: centos安装python3 -– 以下使用执行用户操作 为执行用户创建python3安装目录 mkdir -p /home/rhzl/bin/Python-v3.7.3 下载python3.7的包，有两种方法，一种是从官网下载，然后上传到CentOS上，另一种可以通过CentOS的wget命令直接下载。两者都可以。 mkdir -p /home/rhzl/tool/ cd ~/tool wget https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz 解压到当前目录 #解压 tar -zxvf Python-3.7.3.tgz 进入Python-3.7.3目录，执行配置、编译及安装 cd Python-3.7.3 # 配置 ./configure # 编译 make # 安装 make install 验证安装是否正确 输入python3 -version 如果显示的版本号是3.7.3，就代表安装成功了（CentOS会自带一个python2.7） # 验证python，如果显示的版本号是3.7.3，就代表安装成功了（CentOS会自带一个python2.7） python3 --version # 验证pip，看看pip的版本号是不是10.0.1，以及最后括号里是不是3.7 # 注意！！！如果发现pip3不好使，则需要检查pip3,pyvenv-3.7等bin目录下的命令文件，将第一行的python3命令路径调整为正确的路径: #!/home/rhzl/bin/Python-v3.7.3/usr/local/bin/python3.7 pip3 --versionSTEP3: 安装cmake 切换到/usr/local目录，获取CMake源码包 cd /usr/local # 下载cmake wget https://github.com/Kitware/CMake/releases/download/v3.13.2/cmake-3.13.2.tar.gz 解压CMake源码包, 进入目录 tar -zxvf cmake-3.13.2.tar.gz cd cmake-3.13.2 编译、构建、安装 ./bootstrap make make install DESTDIR=/home/rhzl/bin/cmake 配置环境变量 echo &quot;export PATH=/home/rhzl/bin/cmake/usr/local/bin:$PATH&quot;&gt;&gt;~/.bashrc source ~/.bashrc 查看版本 cmake --versionSTEP4: 安装求解器SCIP在/usr/local目录下操作： 从SCIPOPT官网 ,下载6.0.2套件及4.0版本的header文件，并将两个文件传到/usr/local/目录下• scipoptsuite-6.0.2.tgz• scipoptheaders-4.0.0.tgz 解压scipoptsuite-6.0.2.tgz，进入目录 tar -zxvf scipoptsuite-6.0.2.tgz 在scipoptsuite-6.0.2目录下创建build目录，并在build目录下, 对上级目录执行cmake cd scipoptsuite-6.0.2 mkdir build cd build cmake .. 检查cmake结果，确保以下红框中的package存在 执行构建及安装 #先在/home/rhzl/bin/下创建scipoptsuite目录 mkdir -p /home/rhzl/bin/scipoptsuite #执行安装 make make install DESTDIR=/home/rhzl/bin/scipoptsuite 在home目录下.bash_profile文件中，加入环境变量 vi ~/.bash_profile #增加PATH环境变量 PATH=&quot;${PATH}:/home/rhzl/bin/scipoptsuite/usr/local/bin/scipoptsuite-6.0.2/build/bin&quot; 执行scip，检查安装结果 STEP5: 安装求解器Py客户端连接插件（pyscipypt）好了到了本篇最最关键的一步，成败在此一举，若安装失败则请核对之前所有步骤，若有出入在版本校准/查缺补漏后，重新编译安装scip 安装PyScipopt python3 -m pip install PySCIPOpt==2.2.3 在home目录下.bashrc文件中，添加so文件搜索路径 vi ~/.bashrc #添加以下配置 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/rhzl/bin/Python-v3.7.3/usr/local/lib:/usr/local/lib source ~/.bashrc 验证是否安装成功 # 启动python python3 &gt;&gt; from pyscipopt import Model如果没有引入报错，则安装成功","categories":[{"name":"技术","slug":"技术","permalink":"http://ajayhao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"http://ajayhao.github.io/tags/python/"}]},{"title":"留一半相思上大道","slug":"may-luck-and-tenderness-be-with-you","date":"2021-03-17T16:00:46.000Z","updated":"2021-03-17T16:00:46.000Z","comments":true,"path":"2021/03/18/may-luck-and-tenderness-be-with-you/","link":"","permalink":"http://ajayhao.github.io/2021/03/18/may-luck-and-tenderness-be-with-you/","excerpt":"","text":"又一次和那么多人擦身而过了。。有些甚至不止在一个战壕里蹲过坑打过仗，这样那样的原因，终究又是一次离别。 是非曲折没必要再纠结，因果对错此刻也不再重要。都跨出去了，就坚定的把未来的路走好吧。 最诚挚的祝福给到真诚善待我的人。 还有一位特别的朋友，有幸能一起经历这些刻骨铭心的事，必然会成为永生难忘的回忆。 人间自有真情在，愿君安好，执此流年。","categories":[{"name":"生活","slug":"生活","permalink":"http://ajayhao.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://ajayhao.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"Confluence安装踩坑实录(Docker安装)","slug":"confluence-trial","date":"2021-03-10T09:00:00.000Z","updated":"2021-03-10T09:00:00.000Z","comments":true,"path":"2021/03/10/confluence-trial/","link":"","permalink":"http://ajayhao.github.io/2021/03/10/confluence-trial/","excerpt":"","text":"安装步骤参考三度大神博文：Docker 部署 Confluence(破解版) [toc] 1. docker的镜像安装太慢centos 7下设置国内镜像方法： 使用阿里云容器服务，登录后首页点击“创建我的容器镜像” 得到一个专属的镜像加速地址 修改/etc/docker/daemon.json中的代理信息，如果没有在目录下创建该文件。 替换原地址，启用加速器。 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39; { &quot;registry-mirrors&quot;: [&quot;https://km3an9hh.mirror.aliyuncs.com&quot;] } EOF sudo systemctl daemon-reload sudo systemctl restart docker 2. mysql启动失败镜像启动后立刻关闭，查询日志报 mysqld: Error on realpath() on ‘/var/lib/mysql-files’ (Error 2 - No such file or directory， 为需要指定/var/lib/mysql-files的外部目录 创建my.cnf并启动容器时直接绑定（参考文档： https://www.cnblogs.com/ybyn/p/13698058.html，勘误：文中datadir不用自定义） docker run --restart=unless-stopped -d --name mysql -v /opt/mysql_docker/conf/my.cnf:/etc/mysql/my.cnf -v /opt/mysql_docker/data:/var/lib/mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql 3. SSL开启导致的workbench连接报错关闭ssl方法： 在my.cnf中增加一段配置 skip_ssl重启docker后生效 ###4. 连接时报Public Key Retrieval is not allowedSQLState - 08001com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Public Key Retrieval is not allowed在连接字符串后面加上 &amp;allowPublicKeyRetrieval=true###5. 再次报错：mysql ERROR 1045 (28000): Access denied for user … (using password: YES)权限问题， 执行以下命令 CREATE USER &#39;confuser&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;; ALTER USER &#39;confuser&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;; grant all on confdb.* TO &#39;confuser&#39;@&#39;%&#39;; flush priviledges;###6. 再再次报错：您的数据库必须使用’READ-COMMITTED’作为默认隔离级别。1.url连接字符串增加事务级别参数： &amp;sessionVariables=transaction_isolation=&#39;READ-COMMITTED&#39;2.或者调整整体事务级别 # confluence要求设置事务级别为READ-COMMITTED set global tx_isolation=&#39;READ-COMMITTED&#39;;###7. confluence调整数据库1.在confluence映射目录下找到confluence.cfg.xml文件，将安装阶段恢复成初始。将 &lt;setupStep&gt;complete&lt;/setupStep&gt; 调整为 &lt;setupStep&gt;setupstart&lt;/setupStep&gt; 2.删除confluence.cfg.xml节点属性包含hibernate的所有配置 3.把对应数据源的jar包(比如Oracle的ojdbc8.jar)放到confluence工程的lib目录下(/opt/atlassian/confluence/confluence/WEB-INF/lib) 4.重启confluence，访问主页会重新进入安装引导。","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://ajayhao.github.io/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"浅谈融资租赁的几种业务模式","slug":"financial-lease","date":"2021-02-13T13:18:00.000Z","updated":"2021-02-13T13:18:00.000Z","comments":true,"path":"2021/02/13/financial-lease/","link":"","permalink":"http://ajayhao.github.io/2021/02/13/financial-lease/","excerpt":"[toc] 突然与这个业务产生了一些缘分，好奇也好预习也罢，做了一些功课。 一来是将东拼西凑的知识点做个简单的梳理，二是从生活中一些例子来模拟和类比阐述，可能略有偏差，但求能简单理解诸个业务场景。","text":"[toc] 突然与这个业务产生了一些缘分，好奇也好预习也罢，做了一些功课。 一来是将东拼西凑的知识点做个简单的梳理，二是从生活中一些例子来模拟和类比阐述，可能略有偏差，但求能简单理解诸个业务场景。 供应链金融与融资租赁供应链金融主要包括三大类： 对核心企业上游供应商的应收账款融资，主要以保理、商票保贴、票据贴现等产品为主 对核心企业下游经销商的预付款或应付款融资 对下游企业单纯的存货质押融资，以存货质押获取授信 融资租赁是一项动产融资工具，其租赁物为动产，租赁物多为设备。市面上大多数金租公司都是背靠航空航运、物流运输等集团企业，因其产业特性，在制品、运输链条中重型设备几乎全程参与（锅炉生产、集装箱存储；车、船、飞机运输等等）。设备属于货物，货物属于动产，这成为融资租赁与供应链金融的契合点。 融资租赁业务模式 直接租赁 回租租赁 转租赁 委托租赁 1. 直接租赁直接融资租赁，是指出租人根据承租人(用户) 的请求，与第三方(供货商) 订立供货合同，根据此合同，出租人出资向供货商购买承租人选定的设备。同时，出租人与承租人订立一项租赁合同，将设备出租给承租人，并向承租人收取一定的租金。在整个租赁期间承租人没有所有权但享有使用权，并负责维修和保养租赁物件。合同期满付清租金后，承租人有权按照残值购入租赁物，以拥有其所有权。不论出租人是否将租赁物销售给承租人，均属于融资租赁。 业务流程图： 生活场景： &emsp;&emsp;直接租赁 ———— 小王和小李是一对好朋友，小王是个游戏迷，小李很有经济头脑。一直以来小王都是买游戏卡带玩，每次买了卡带玩不多久就仍一边儿了，可新游戏层出不穷，市场价动辄五六百，小王觉得太烧钱了，可不玩又特难受，于是求助小李。 小李为他出了个主意， 他根据小王的需求买下最新的游戏卡带，并按每天20块钱的价格租给小王玩，3天起租，5天为一个租期，如果续租满1个月，小王即可永久保存该卡带。 于是小王可以以几十块钱的体验价玩一款游戏，真正喜欢的游戏也能长期保存。小王朋友圈里数十位游戏好友知悉此事后，也纷纷点赞并加入其中。过不多久，小李开了个游戏出租店，以这个模式买新游戏出租给客户，生意兴隆。 2. 售后回租售后回租是指承租人以融资为目的，将资产出售给出租人，同时与出租人签订融资租赁合同，再将该资产从出租人处租回的融资租赁形式。即卖方兼承租人，买方兼出租人。租赁期间，租赁资产的所有权发生转移，承租人只拥有租赁资产的使用权。双方可以约定在租赁期满时，由承租人继续租赁或者以约定价格由承租人回购租赁资产。采用这种租赁方式可使承租人迅速回收购买物品的资金，加速资金周转。回租的对象多为已使用的旧物品，有利于承租人盘活已有资产，可以快速筹集企业发展所需资金，顺应市场需求。 业务流程图： 生活场景： &emsp;&emsp;售后回租 ———— 月光族小张也是个游戏迷，好不容易攒钱买了款3A游戏大作，却因为疫情意外丢了工作。掌管财政大权的妻子为了不让小张在家懈怠，决定不给小张零花钱，要其自食其力赶紧找工作。小张碍于面子又不敢和家人联系，断了经济来源他一时不知如何是好，于是找上了小李。小李想了想，直接借钱虽然省事可有悖张妻的初心，于是顿生一计，他以市场价95折的价格直接买下了小张的游戏卡带，并租给小张玩，小张有了钱直接解决了短日的生计，同时也有的玩。一周后小张顺利找到新工作，期间生活游玩两不误，小李的游戏出租店生意也越发红火了。 3. 转租赁转租赁是以同一物件为标的物的多次融资租赁业务。 转租赁业务由租赁公司作为承租人，向其他租赁公司租回用户所需要的设备，再将该设备租赁给承租企业使用，原租约与转租约同时并存有效。在转租赁业务中，上一租赁合同的承租人同时又是下一租赁合同的出租人，称为转租人。转租人向其他出租人租入租赁物件再转租给第三人，转租人以收取租金差为目的，租赁物品的所有权归第一出租人。 业务流程图： 生活场景： &emsp;&emsp;转租赁 ———— 一来二往，小王已经成为小李的超级VIP客户，再加上故友旧情，小李对于小王的需求可是偏袒有加，任何热门游戏，只要小王需要，总是能在第一时间满足，租期也越发宽松。 小王是每次能尝到鲜，但游戏卡僧多粥少，可苦了其他小伙伴，只好等第一批玩好才能租到，要不就只好自己掏钱买。 几番经历后，小王也有了生意经， 一些热门游戏租到后，小王会废寝忘食抓紧玩通关，然后转给需要的小伙伴，对于一些自己不是特别发烧的游戏类型，小王甚至会做些“牺牲”，加一些价格转给其他小伙伴优先游玩。 这样一来，小王的游玩体验并没有太大影响， 而租游戏的成本又大幅度下降，真是一箭双雕的好买卖。 4. 委托租赁委托租赁是拥有资金或设备的人委托非银行金融机构从事融资租赁，第一出租人同时是委托人，第二出租人同时是受托人。出租人接受委托人的资金或租赁标的物，根据委托人的书面委托，向委托人指定的承租人办理融资租赁业务。 在租赁期内租赁标的物的所有权归委托人，出租人只收取手续费，不承担风险。租赁期满后，租赁标的物的所有权可以转移给承租人，也可以不转移给承租人（返还给委托人）。 业务流程图： 生活场景： &emsp;&emsp;委托租赁 ———— 小李的生意越发红火，可经营一段时间后发现，热门的游戏供不应求，可也有一些小众游戏出租率很低，进货亏本不进呢满足不了需求也会有客户流失，于是小李找到了骨灰级游戏发烧友小陈。与小王不同的是，小陈喜欢淘一些小众游戏，自己也收藏了许多绝版游戏。 时而也有朋友有偿想要借着玩，可小陈嫌算钱麻烦，搞丢了啥的也不知道怎么个索赔，甚至借出的多了还会遗忘。 于是小李与小陈一合计，有了美妙的方案：一些小众稀缺游戏卡带，小李会直接询问小陈是否珍藏且是否有意愿出借，如果小陈愿意，他会与小陈和客户一起商量出一个可接受的租价，小陈将卡带给到小李，全权委托小李将操办卡带的租赁业务，毕竟这块小李更专业嘛，小李也愿意接受委托，大家一起发财。 于是乎小陈的小众卡带有了市场，小李的业务渠道也更宽了。 几种模式比较 融资租赁模式 适用特性 模式优势 直接租赁 1.固定资产、大型设备购置2.企业技术改造和设备升级 1.降低企业购置设备、厂房自筹资金比例，缓解企业前期资金压力2.企业可灵活租金支付方式，实现现金支出与流入匹配 售后回租 1.流动资金不足的企业2.具有新投资项目而自有资金不足的企业3.持有快速升值资产的企业 1.最高可得到设备净值70-80%的融资，有效缓解企业营运资金不足2.无需抵押物等附加条件，降低融资门槛3.有利于企业优良资产的保值增值 转租赁 子公司融资便利 1.有利于发挥专业优势、避免关联交易2.避免出现搁浅资产，而且对转租人而言，可以改进企业的利润，改善财务报表，提高资产回报率 委托租赁 没有租赁经营权的企业，可以“借权”经营 1.委托租赁可以实现集团公司或关联方资金注入方式的多样化2.委托租赁也可以使企业享受加速折旧的好处，调节客户税前利润，调整所得税支出3.委托租赁可以使资金使用方和资金委托方二者关系清晰，便于确定双方的权利义务","categories":[{"name":"金融业务","slug":"金融业务","permalink":"http://ajayhao.github.io/categories/%E9%87%91%E8%9E%8D%E4%B8%9A%E5%8A%A1/"}],"tags":[{"name":"金融","slug":"金融","permalink":"http://ajayhao.github.io/tags/%E9%87%91%E8%9E%8D/"}]},{"title":"与熊论个道","slug":"bear-zen-talk","date":"2020-08-29T13:51:00.000Z","updated":"2020-08-29T13:51:00.000Z","comments":true,"path":"2020/08/29/bear-zen-talk/","link":"","permalink":"http://ajayhao.github.io/2020/08/29/bear-zen-talk/","excerpt":"","text":"听熊说自然的奥秘，领悟熊所言的真谛。。。233333 熊曰：呋食食嘶動呦歡嚁喜肉註我擊住唬哈爾現寶呦動常現有類嗡嚁嘶性咯圖呱物人你“中国版的摩斯密码”吹的有些过头， 但密文的整体压缩率还是让人眼前一亮的， 貌似目前阶段嘛除了拿来和度娘、网易的吧主斗智斗勇， 也没有更多“实用“和有意义的场景了。 而且“熊曰：呋”这个起手式也太明显了， 没有被针对也只是因为目前还没那么火吧。。 Whatever，“坑晨”牛逼，值得吹一波，然也~。","categories":[{"name":"技术","slug":"技术","permalink":"http://ajayhao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://ajayhao.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"SpringBoot Logging配置","slug":"springboot-logging-config","date":"2020-05-21T03:57:47.000Z","updated":"2020-05-21T03:57:47.000Z","comments":true,"path":"2020/05/21/springboot-logging-config/","link":"","permalink":"http://ajayhao.github.io/2020/05/21/springboot-logging-config/","excerpt":"","text":"一. 版本变化: SpringBoot1.x版本使用logging.path配置日志路径，logging.file配置日志文件 SpringBoot2.0之后使用logging.file.path配置日志路径，logging.file.name配置日志文件名称 二. logging.file.name 和 logging.file.path 区别： logging.file.name 设置具体输出的日志名称，可以带路径(绝对路径/基于当前运行目录的相对路径) logging.file.path 日志会以默认文件名spring.log写到指定目录 若同时配置，以logging.file.name配置为准 三. 结合logback注意事项 引入logback是为了对日志进行精细化管理，使用外置化的xml(一般为logback-spring.xml)，设置特定类、模块的日志记录级别，记录方式等 SpringBoot中配置如下 logging: config: classpath:logback-spring.xml 由于LogBack比SpringBoot先初始化，若启动时出现LOG_PATH_IS_UNDEFINED文件夹，则需将LOG_PATH的value中改成${LOG_PATH:-.}，如下图 logging: path: /var/logs/xxx classpath:logback-spring.xml 四. 最佳实践 若不需要对log进行精细化管理，推荐使用logging.file.name，便于SpringBoot自带actuator中的logfile接口能够直接扫描获取日志信息，便于SpringBootAdmin等监控工具集成。 若在使用logback同时希望使用SpringBoot的日志监控，则需添加额外配置指定日志路径 management: endpoint: logfile: external-file: &lt;logpath&gt;/xxx.log","categories":[{"name":"技术","slug":"技术","permalink":"http://ajayhao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://ajayhao.github.io/tags/Java/"}]},{"title":"Java 8 进阶系列 - 初识Optional类","slug":"java8-optional","date":"2020-03-31T03:05:47.000Z","updated":"2020-03-31T03:05:47.000Z","comments":true,"path":"2020/03/31/java8-optional/","link":"","permalink":"http://ajayhao.github.io/2020/03/31/java8-optional/","excerpt":"","text":"[toc] 一. 概述&emsp;&emsp;在Java8之前，null值的判断一直是困扰Java程序员的问题，大家可能都有这样的经历：调用一个方法得到了返回值却不能直接将返回值作为参数去调用别的方法。我们首先要判断这个返回值是否为null，只有在非空的前提下才能将其作为其他方法的参数。为了防止NullPointException的出现，我们不得不编写大量的防御性代码，如下例所示： Passenger passenger = SomeMehtod.getPassenger(); if(passenger != null &amp;&amp; passenger.getCert() != null &amp;&amp; passenger.getCert().getPersonalInfo != null){ return passenger.getCert().getPersonalInfo().getName(); } else return &quot;default name&quot;;&emsp;&emsp;对于嵌套比较深的类，上述代码太常见了，大段的&amp;&amp;条件判断非常容易出错，同时代码可读性也非常差。 &emsp;&emsp;Java 8引入了新的Optional类，专门用来解决null值问题，对于嵌套类的空判断，使用Optional比传统的层层剥皮判断要更加优雅，代码量也会少很多。然而需要特别说明的是，目前Optional的最优场景还是建议配合Stream API使用。如果不结合Stream API来看，虽然也能改造相当一部分if else冗余嵌套的场景，但Optional也可能会让代码变得更冗余，过犹不及，需要结合具体场景具体分析。 &emsp;&emsp;本文会逐个探讨Optional类包含的方法，并通过一两个示例展示如何使用。 二. 方法及示例1. of 为非null的值创建一个Optional。 &emsp;&emsp; of方法通过工厂方法创建Optional类。需要注意的是，创建对象时传入的参数不能为null。如果传入参数为null，则抛出NullPointerException。 //调用工厂方法创建Optional实例 Optional&lt;String&gt; name = Optional.of(&quot;Sanaulla&quot;); //传入参数为null，抛出NullPointerException. Optional&lt;String&gt; someNull = Optional.of(null);2. ofNullable 为指定的值创建一个Optional，如果指定的值为null，则返回一个空的Optional。 &emsp;&emsp;ofNullable与of方法相似，唯一的区别是可以接受参数为null的情况。示例如下： //下面创建了一个不包含任何值的Optional实例 //例如，值为&#39;null&#39; Optional empty = Optional.ofNullable(null);3. isPresent 非常容易理解，如果值存在返回true，否则返回false。 //isPresent方法用来检查Optional实例中是否包含值 if (name.isPresent()) { //在Optional实例内调用get()返回已存在的值 System.out.println(name.get());//输出Sanaulla }4. get 如果Optional有值则将其返回，否则抛出NoSuchElementException。 &emsp;&emsp;上面的示例中，get方法用来得到Optional实例中的值。下面我们看一个抛出NoSuchElementException的例子： //执行下面的代码会输出：No value present try { //在空的Optional实例上调用get()，抛出NoSuchElementException System.out.println(empty.get()); } catch (NoSuchElementException ex) { System.out.println(ex.getMessage()); }5. ifPresent 如果Optional实例有值则为其调用consumer，否则不做处理。 &emsp;&emsp;要理解ifPresent方法，首先需要了解Consumer类。简答地说，Consumer类包含一个抽象方法。该抽象方法对传入的值进行处理，但没有返回值。Java8支持不用接口直接通过lambda表达式传入参数。&emsp;&emsp;如果Optional实例有值，调用ifPresent()可以接受接口段或lambda表达式。类似下面的代码： //ifPresent方法接受lambda表达式作为参数。 //lambda表达式对Optional的值调用consumer进行处理。 name.ifPresent((value) -&gt; { System.out.println(&quot;The length of the value is: &quot; + value.length()); });6. orElse 如果有值则将其返回，否则返回指定的其它值。 &emsp;&emsp;如果Optional实例有值则将其返回，否则返回orElse方法传入的参数。示例如下： //如果值不为null，orElse方法返回Optional实例的值。 如果为null，返回传入的消息。 System.out.println(empty.orElse(&quot;There is no value present!&quot;)); //输出：There is no value present! System.out.println(name.orElse(&quot;There is some value!&quot;)); //输出：Sanaulla7. orElseGet 如果有值则将其返回，否则返回指定的其它值。 &emsp;&emsp;orElseGet与orElse方法类似，区别在于得到的默认值。orElse方法将传入的字符串作为默认值，orElseGet方法可以接受Supplier接口的实现用来生成默认值。示例如下： //orElseGet与orElse方法类似，区别在于orElse传入的是默认值， //orElseGet可以接受一个lambda表达式生成默认值。 //输出：Default Value System.out.println(empty.orElseGet(() -&gt; &quot;Default Value&quot;)); //输出：Sanaulla System.out.println(name.orElseGet(() -&gt; &quot;Default Value&quot;));8. orElseThrow 如果有值则将其返回，否则抛出supplier接口创建的异常。 &emsp;&emsp;在orElseGet方法中，我们传入一个Supplier接口。然而，在orElseThrow中我们可以传入一个lambda表达式或方法，如果值不存在来抛出异常。示例如下： try { //orElseThrow与orElse方法类似。与返回默认值不同， //orElseThrow会抛出lambda表达式或方法生成的异常 empty.orElseThrow(ValueAbsentException::new); } catch (Throwable ex) { //输出: No value present in the Optional instance System.out.println(ex.getMessage()); }9. map&emsp;&emsp;map方法用来对Optional实例的值执行一系列操作。通过一组实现了Function接口的lambda表达式传入操作。 //map方法执行传入的lambda表达式参数对Optional实例的值进行修改。 //为lambda表达式的返回值创建新的Optional实例作为map方法的返回值。 Optional&lt;String&gt; upperName = name.map((value) -&gt; value.toUpperCase()); System.out.println(upperName.orElse(&quot;No value found&quot;));10. flatMap&emsp;&emsp;flatMap方法与map方法类似，区别在于mapping函数的返回值不同。map方法的mapping函数返回值可以是任何类型T，而flatMap方法的mapping函数必须是Optional。 //map方法中的lambda表达式返回值可以是任意类型，在map函数返回之前会包装为Optional。 //但flatMap方法中的lambda表达式返回值必须是Optionl实例。 upperName = name.flatMap((value) -&gt; Optional.of(value.toUpperCase())); System.out.println(upperName.orElse(&quot;No value found&quot;));//输出SANAULLA11. filter&emsp;&emsp;filter个方法通过传入限定条件对Optional实例的值进行过滤。 如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。 //filter方法检查给定的Option值是否满足某些条件。 //如果满足则返回同一个Option实例，否则返回空Optional。 Optional&lt;String&gt; longName = name.filter((value) -&gt; value.length() &gt; 6); System.out.println(longName.orElse(&quot;The name is less than 6 characters&quot;));//输出Sanaulla //另一个例子是Optional值不满足filter指定的条件。 Optional&lt;String&gt; anotherName = Optional.of(&quot;Sana&quot;); Optional&lt;String&gt; shortName = anotherName.filter((value) -&gt; value.length() &gt; 6); //输出：name长度不足6字符 System.out.println(shortName.orElse(&quot;The name is less than 6 characters&quot;));三. 综合运用&emsp;&emsp;下面的代码是在实际项目中的综合运用，Optional分别应用于对象和集合，供参考。 final SrInfo srInfo = querySrDetail(srId); //仅系统为fwpt. 且选择需要通知时，才推送客服邮件 Optional.ofNullable(srInfo).filter(item -&gt; &quot;fwpt&quot;.equals(item.getMainSysFlag()) &amp;&amp; &quot;1&quot;.equals(item.getNotifyFlag())) .ifPresent(item -&gt; { List&lt;String&gt; csUsers = queryCustomerServiceRole(); Map&lt;String, Object&gt; paramMap = srEntityHelper.buildCsMailParamMap(item); List&lt;String&gt; attachList = Optional.ofNullable(srInfo.getAttachmentList()).map(list -&gt; list.stream() .map(SrAttachment::getAttachmentId).collect(Collectors.toList())).orElse(null); EmailMessageParam emailMessageParam = MailParamBuilder.buildMailContent( SrMailTemplateEnum.MAIL_FWPT_PASS_REVIEW.getCode(), csUsers, null, paramMap, attachList ); srRemoteService.sendSrMail(emailMessageParam); });","categories":[{"name":"技术","slug":"技术","permalink":"http://ajayhao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://ajayhao.github.io/tags/Java/"}]},{"title":"全球公开大数据平台资料集锦","slug":"collection-of-bigdata-tools","date":"2020-03-29T06:38:36.000Z","updated":"2020-03-29T06:38:36.000Z","comments":true,"path":"2020/03/29/collection-of-bigdata-tools/","link":"","permalink":"http://ajayhao.github.io/2020/03/29/collection-of-bigdata-tools/","excerpt":"","text":"[toc] 一. 工具篇1. 阿里DataV：(https://data.aliyun.com/visual/datav)&emsp;&emsp;DataV已经是比较成熟的商业产品，分基础版、企业版、开发版等，不同版本的功能支持也不尽相同。专业级大数据可视化、多种数据源支持、便捷的图形化编辑界面、灵活部署和发布，好是各种好，贵也各种贵。。。 2. 百度Sugar：(https://sugar.baidu.com/)&emsp;&emsp;百度Sugar是与阿里云DataV类似的产品，目前正处于公测阶段，可免费使用。但相比目前成熟的DataV，百度Sugar能提供的行业模板还很少，支持的数据源类型也较少，操作的便捷性上有很多细节需要完善。但因为有ECharts的加持，报表渲染比较流畅，目前也能支持以现有已完成的大屏为模板进行新建项目。 3. 腾讯云图：(https://cloud.tencent.com/product/tcv)&emsp;&emsp;腾讯家的数据可视化产品，感觉就工具而言BAT三家的都基本都够用，主要还是看与自身项目及搭建平台的选择，如果是已经上云的产品和项目，优先推荐相对应的云平台产品，毕竟统一的产品线在部署运维各方面都会有更好的支持。 4. Flourish：(https://flourish.studio/)&emsp;&emsp;老外的网站，有不少免费的图表库，在油管上看到有播主上传的手把手教程，10分钟搞定动态条形图，简单易懂，推荐一下。 二. 资料篇1. 世界银行：(https://data.worldbank.org.cn)&emsp;&emsp;这是世界银行的公开数据平台，任何人都可免注册登陆，免费并公开获取世界各国的发展数据。有中文版，可以按国家、专题、指标来浏览，也可键入关键词搜索。在首页即可选择查看世界发展指标、世界银行财务、项目、开放型政府工具箱。若想查看更多数据，就试试查询所有213项数据目录吧。 2. 欧盟数据门户 (https://data.europa.eu/euodp/en/data/)&emsp;&emsp;囊括了来自34个国家、总计达24万的数据集。数据分为从农业到交通等13个类别，包括科学、司法、卫生，这能让你按照分类浏览。支持多语言检索界面，还使用了机器翻译技术的重要数据描述符。 3. 公开数据门户 (https://opendatainception.io)&emsp;&emsp;整合全球1600个公开数据门户的数据目录，如数据平台OpenGeocode（免费公共地理位置数据库），Dataportals（公开数据门户），问答门户Quora和StackExchange等都被统统囊括其中。 4. 联合国千年发展目标报告UN MDG Reports (https://unstats.un.org/unsd/mdg/host.aspx?content=products/links.htm)5. 联合国开发计划署报告 (http://hdr.undp.org)&emsp;&emsp;2019人类发展统计数据表，人类发展报告，支持分国家、数据地理范围、主题、年份、语言、设定浏览方式或检索，还有讨论发展议题的博客。 6. 联合国统计司 (https://unstats.un.org/home/)&emsp;&emsp;其数据库包含联合国千年发展数据和国民核算主要总量数据库（National Accounts Main Agregates Database），以及《联合国统计月报》在线，强大到没朋友。 7. 联合国数据 (https://data.un.org)&emsp;&emsp;由联合国统计司发起的提供联合国数据的检索门户网站，既然顶着“联合国”的头衔，它的容量也是不言而喻：容纳17个机构提供的34个数据库，总计达6千万条记录，覆盖农业、犯罪、教育、就业、能源、环境、卫生、艾滋、人类发展、工业、信息和通讯技术、国家审计、人口、难民、旅游、贸易和千年发展计划的数据。不光是数据库，数据表格和词汇表也可供用户查阅哦。 8. 联合国环境统计数据 (https://unstats.un.org/unsd/envstats/questionnaire)&emsp;&emsp;包含联合国统计司的环境数据，也涵盖其他八个主题。 9. 联合国教科文组织国际教育统计数据库（UNESCO International Education StatisticsDatabase）&emsp;&emsp;目前已覆盖200多个国家和地区的所有级别的教育，阐释例如性别差异、教师和资金等关键政策问题。 10. 妇女观察（Women Watch）&emsp;&emsp;提供关于《北京行动纲领》提出的关键议题、将性别观点纳入社会主流、以及气候变化等联合国全球议程重点议题的在线数据。 11. 联合国人口基金统计数据和出版物（UNFPA Statistics and Publications）&emsp;&emsp;可按关键词、出版物类型、主题和出版时间划分 12. 联合国水资源统计数据门户(UN Water Statistics Portal)&emsp;&emsp;可点选主题筛选。 13. 世界卫生组织-全球卫生观察站(WHO Global Health Observatory)&emsp;&emsp;国家数据和统计信息，重点为对照性估计数；世卫组织为监测全球、区域和国家情况与趋势作出的分析。包含：主体信息、数据库、国家数据和分析报告。 14. 全球经济指标数据网 (https://zh.tradingeconomics.com/)","categories":[{"name":"技术","slug":"技术","permalink":"http://ajayhao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://ajayhao.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"可视化","slug":"可视化","permalink":"http://ajayhao.github.io/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"}]},{"title":"Python打包exe文件压缩","slug":"pyinstaller-reduce-file-size","date":"2020-03-22T04:04:00.000Z","updated":"2020-03-22T04:04:00.000Z","comments":true,"path":"2020/03/22/pyinstaller-reduce-file-size/","link":"","permalink":"http://ajayhao.github.io/2020/03/22/pyinstaller-reduce-file-size/","excerpt":"","text":"&emsp;&emsp;前几周给产品组做了个抓OA流程数据算处理时效的需求，爬虫相关的小工具，自然而然就用python啦，等要交付的时候发现打出的exe包实在太大啊，一个小功能将近200M（Orz…）, 于是遍寻瘦身之道，这边推荐CodingDog在知乎上的解答，给了四种“玄学”解法（其实都是很科学的方案，给大神点赞~），直接给传送门： Python 打包成 exe，太大了该怎么解决？ by CodingDog &emsp;&emsp;作为一名python小白，这里着力推荐一下解法3，简洁易懂开箱即用。由于真实的python运行环境中安装的库多而全，pyinstaller默认会把很多没用到底库一起打包进来，实际程序用不到那么多库，打完的程序包就显得很臃肿。 精简打包就需要把不相关的依赖排除掉，人工筛查工作量不小，同时需要对模块的底层依赖和第三方依赖非常清晰，稍有不慎就会出错。解法3的妙处在于其他方案是做减法，而解法3是从0做加法， 核心思想是创建一个干净的python虚拟环境，在没有任何依赖的情况下，逐个叠加依赖库。 创建虚拟环境的工具也有很多，如virtualenv、pipenv，下文以pipenv做演示。 &emsp;&emsp;具体操作步骤如下： 1.首先安装pipenv pip install pipenv2.创建个目录作为虚拟环境，如命名为newenv，在该目录下创建虚拟环境 #进到newenv目录下 cd D:\\Software\\Develop\\newenv #建立虚拟环境 pipenv install 3.进入虚拟环境，通过命令行盘符路径前带括号的环境信息来判断是否进入成功 pipenv shell 4.逐个安装构建项目需要依赖的模块，如本例中的requests、 pyquery，安装完毕后，最后安装pyinstaller pip install requests pip install pyquery ... pip install pyinstaller5.开始打包工程文件 pyinstaller -F D:\\GitRepo\\helloPy\\GtjaOATool\\oaprocess.py打包后，找到目录dist中的exe文件（所在目录：D:\\Software\\Develop\\newenv\\dist），顺利打开~。 可以看到压缩后的文件只有11M。","categories":[{"name":"技术","slug":"技术","permalink":"http://ajayhao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"http://ajayhao.github.io/tags/python/"}]},{"title":"Java 8 进阶系列 - Stream API","slug":"java8-stream-api","date":"2020-03-14T08:15:47.000Z","updated":"2020-03-14T08:15:47.000Z","comments":true,"path":"2020/03/14/java8-stream-api/","link":"","permalink":"http://ajayhao.github.io/2020/03/14/java8-stream-api/","excerpt":"","text":"[toc] 一. 前言（一）概述&emsp;&emsp;Stream API是Java 8版本的又一大利器，借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。 尤其对于集合元素的遍历、过滤、数据汇聚等方面，在早版本的迭代器之外给另一种更优的方案。 &emsp;&emsp;Stream API提供串行和并行两种模式，串行模式与传统Iterator类似，数据按照一个方向流动，进行单向处理；而并发模式能够充分利用多核处理器的优势。 &emsp;&emsp;Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错，但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。 （二）流的操作分类1. Intermediate（中间操作） &emsp;&emsp; Intermediate具有Lambda延迟性，不会立刻触发操作。 一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射 / 过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。 &emsp;&emsp; 中间操作又可以分为无状态的(Stateless)和有状态的(Stateful)，无状态的中间操作是指元素的处理不受前面元素的影响，而有状态的中间操作必须等到所有元素处理之后才知道最终结果，比如排序是有状态操作，在读取所有元素之前并不能确定排序结果，filter是无状态操作，符合过滤条件就被选出来，不关注其他元素的状态。 2. Terminal（终止操作） &emsp;&emsp; Terminal触发整个流的操作。 一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用 “光” 了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且生成结果。 &emsp;&emsp;终止操作又可以分为短路操作和非短路操作，短路操作是指不用处理全部元素就可以返回结果，比如找到第一个满足条件的元素。 操作类型 接口方法 Intermediate（中间操作） 无状态(Stateless) map(mapToInt、mapToLong、flatmap、mapToDouble、 flatMapToInt、flatMapToLong、flatMapToDouble)、unordered、filter、 peek、 parallel 、sequential 、isParallel 有状态(Stateful) distinct、 sorted、limit、 skip Terminal（最终操作） 非短路操作 forEach、forEachOrdered、 toArray、 reduce、collect、 max、min、count Short-circuiting（短路操作） anyMatch、allMatch、noneMatch、findFirst、 findAny 二. 流的创建（一）常用创建方式1. 独立的值Stream stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);2. 数组String [] strArray = new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}; stream = Stream.of(strArray); stream = Arrays.stream(strArray);3. 集合List&lt;String&gt; list = Arrays.asList(strArray); stream = list.stream();（二）包装类型的构造&emsp;&emsp;可以使用 Stream&lt;Integer&gt;、 Stream&lt;Double&gt;、 Stream&lt;Long&gt; ， 但是装箱、拆箱非常耗时，建议谨慎使用。 IntStream ints = IntStream.of(1,2,3); LongStream longs = LongStream.of(4,5,6); DoubleStream doubles = DoubleStream.of(6,7,8); IntStream.range(1, 10).forEach(System.out::print);// [1,10) 区间 IntStream.rangeClosed(1, 10).forEach(System.out::print);//[1,10] 区间（三）并行流的规则输出&emsp;&emsp;parallel() 方法将普通流转换为并行流 IntStream.range(1, 10).parallel().forEach(System.out::print); // 并行执行 效率高 但是输出结果不具备输入结果的有序性 IntStream.range(1, 10).parallel().forEachOrdered(System.out::print);// 并行执行 效率高 严格要求输出结果按照输入结果顺序（四）流的转换&emsp;&emsp;通过collect() 方法将流中的数据转成集合与值 1. 数组String[] strArray1 = stream.toArray(String[]::new);2. 集合List&lt;String&gt; list1 = stream.collect(Collectors.toList()); List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new)); Set set1 = stream.collect(Collectors.toSet()); Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));3. StringString str = stream.collect(Collectors.joining()).toString();三. 流操作（一）map映射1. 一对一IntStream.of(1,2,3).map(x-&gt;x*2).forEach(System.out::println);2. 合并流Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of( Arrays.asList(1), Arrays.asList(2,3), Arrays.asList(4,5,6)); Stream&lt;Integer&gt; child_stream = inputStream.flatMap(x-&gt;x.stream());3. 合并流到其他类型 - 一对多DoubleStream doubleStream = inputStream.flatMapToDouble(x-&gt;x.stream().mapToDouble(Double::new)); IntStream intStream = inputStream.flatMapToInt(x-&gt;x.stream().mapToInt(Integer::new)); LongStream longStream = inputStream.flatMapToLong(x-&gt;x.stream().mapToLong(Long::new));4. 转大小写、平方数等List&lt;String&gt; output = wordList.stream().map(String::toUpperCase).collect(Collectors.toList()); List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4); List&lt;Integer&gt; squareNums = nums.stream().map(n -&gt; n * n).collect(Collectors.toList()); （二）filter 过滤器//留下偶数 IntStream.range(1, 10).filter(x-&gt;(x&amp;1)==0).forEach(System.out::println); Integer[] sixNums = {1, 2, 3, 4, 5, 6}; Integer[] array = Stream.of(sixNums).filter(x-&gt;(x&amp;1)==0).toArray(Integer[]::new); // 把单词挑出来 List&lt;String&gt; output = reader.lines().flatMap(line -&gt; Stream.of(line.split(REGEXP))).filter(word -&gt; word.length() &gt; 0).collect(Collectors.toList());（三）foreach peek(Intermediate) 输出Stream&lt;List&lt;Integer&gt;&gt; stream = Stream.of(Arrays.asList(1,2,3,4,5,6)); stream.parallel().forEach(System.out::println); stream.parallel().forEachOrdered(System.out::println); //并行 强制有序 // 体现了 访问者设计模式 Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;) .filter(e -&gt; e.length() &gt; 3) .peek(e -&gt; System.out.println(&quot;Filtered value: &quot; + e)) .map(String::toUpperCase) .peek(e -&gt; System.out.println(&quot;Mapped value: &quot; + e)) .collect(Collectors.toList());输出结果： Filtered value: three Mapped value: THREE Filtered value: four Mapped value: FOUR（四）findFirst、findAny&emsp;&emsp;findAny、max/min、reduce 等方法返回Optional 非终结操作，可以对结果继续处理。 使用它的目的是尽可能避免 NullPointerException。 Integer[] sixNums = {1, 2, 3, 4, 5, 6}; Stream.of(sixNums).findFirst().ifPresent(System.out::println); Stream.of(sixNums).findAny().ifPresent(System.out::println); // 返回的Optional 可以加上逻辑排除NPE Integer else1 = Stream.of(sixNums).filter(x-&gt;x&lt;0).findAny().orElse(null);&emsp;&emsp;findFirst、findAny找不到元素抛出NPE。可以加上Or系列方法返回默认值 （五）reduce&emsp;&emsp;这个方法的主要作用是把identity作为第二个参数BinaryOperator 函数的输入,执行操作后返回。 // 字符串连接，concat = &quot;ABCD&quot; String concat = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).reduce(&quot;&quot;, String::concat); // 求最小值，minValue = -3.0 double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); // 求和，sumValue = 10, 有起始值 int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum); // 求和，sumValue = 10, 无起始值 sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get(); // 过滤，字符串连接，concat = &quot;ace&quot; concat = Stream.of(&quot;a&quot;, &quot;B&quot;, &quot;c&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;). filter(x -&gt; x.compareTo(&quot;Z&quot;) &gt; 0). reduce(&quot;&quot;, String::concat);&emsp;&emsp;以上 字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce （六）limit/skip&emsp;&emsp;limit返回Stream的前面n个元素；skip则是扔掉前n个元素 List&lt;String&gt; personList = persons.stream().map(Person::getName).limit(10).skip(3).collect(Collectors.toList()); limit/skip ,放在sorted()后面并不能影响排序的次数 &emsp;&emsp;有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关, 由于系统统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样 并行流情况下不能使用limit() 将会影响并行操作的次序性能 &emsp;&emsp;对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。 （七）排序sortedList&lt;Person&gt; personList2 = persons.stream().limit(2).sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList());（八）min/max/distinct&emsp;&emsp;用 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。 Stream&lt;Integer&gt; stream = Stream.generate(()-&gt;new Random().nextInt()).limit(100); long nums = 100-stream.distinct().count(); Integer max = stream.max(Comparator.naturalOrder()).get(); Integer min = stream.min(Comparator.naturalOrder()).get();（九）match&emsp;&emsp;Stream有三个match方法，从语义上说： allMatch：Stream 中全部元素符合传入的 predicate，返回 true anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true List&lt;Person&gt; persons = new ArrayList(); persons.add(new Person(1, &quot;name&quot; + 1, 10)); persons.add(new Person(2, &quot;name&quot; + 2, 21)); persons.add(new Person(3, &quot;name&quot; + 3, 34)); persons.add(new Person(4, &quot;name&quot; + 4, 6)); persons.add(new Person(5, &quot;name&quot; + 5, 55)); boolean isAllAdult = persons.stream(). allMatch(p -&gt; p.getAge() &gt; 18); System.out.println(&quot;All are adult? &quot; + isAllAdult); boolean isThereAnyChild = persons.stream(). anyMatch(p -&gt; p.getAge() &lt; 12); System.out.println(&quot;Any child? &quot; + isThereAnyChild);四. 流的生成（一）generate&emsp;&emsp;通过Supplier接口，可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。 &emsp;&emsp;generate内部维护一个无限制的循环，根据传入的规则生成数据，需要使用Limit限制数据生成的范围。 Random seed = new Random(); Supplier&lt;Integer&gt; random = seed::nextInt; Stream.generate(random).limit(10).forEach(System.out::println); //Another way IntStream.generate(() -&gt; (int) (System.nanoTime() % 10000)). limit(10).forEach(System.out::println);自定义Supplier Stream&lt;Person&gt; stream2 = Stream.generate(new Use_Max_Min_Distinct().new PersonSupplier()).limit(10); stream2.forEach(System.out::println); private class PersonSupplier implements Supplier&lt;Person&gt;{ private Random random=new Random(); @Override public Person get() { return new Person(&quot;Tom&quot;,random.nextInt()); } } private class Person{ private String name; // Constructor get set toString() }（二）iterate&emsp;&emsp;iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。 &emsp;&emsp;然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。 Stream.iterate(0, n -&gt; n + 3).limit(10).forEach(x -&gt; System.out.print(x + &quot; &quot;)); // 0 3 6 9 12 15 18 21 24 27五. 聚合操作（一）groupingBy&emsp;&emsp;groupingBy是多值的聚合操作，参数是Function 1.默认分组类型(List)Map&lt;String, List&lt;PersonVO&gt;&gt; teamMap = persons.stream() .collect(Collectors.groupingBy(PersonVO::getTeam));2.指定分组类型Map&lt;String, String&gt; teamString = persons.stream() .collect(Collectors.toMap(PersonVO::getTeam, PersonVO::getName, (a,b)-&gt; a+&quot;,&quot;+b));3.分组求和Map&lt;String, Integer&gt; teamString = persons.stream() .collect(Collectors.groupingBy(PersonVO::getTeam, Collectors.summingInt(PersonVO::getAge)));（二）partitioningBy&emsp;&emsp;partitioningBy是单值的操作，参数Predicate Map&lt;Boolean, List&lt;String&gt;&gt; partition = Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;) .collect(Collectors.partitioningBy(t-&gt;Integer.valueOf(t)&gt;3));","categories":[{"name":"技术","slug":"技术","permalink":"http://ajayhao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://ajayhao.github.io/tags/Java/"}]},{"title":"Java 8 进阶系列 - Lambda 表达式","slug":"java8-lets-use-lambda","date":"2020-03-07T14:15:47.000Z","updated":"2020-03-07T14:15:47.000Z","comments":true,"path":"2020/03/07/java8-lets-use-lambda/","link":"","permalink":"http://ajayhao.github.io/2020/03/07/java8-lets-use-lambda/","excerpt":"","text":"[toc] 一. 前言&emsp;&emsp;Lambda表达式是Java 8最重要的一个新特性，它允许我们将行为传到函数里。在Java 8之前，如果想将行为传入函数，仅有的选择就是匿名类，匿名类的写法代码冗长且需要遵循特定的代码模板。Lambda表达式取代了匿名类，取消了模板，允许用函数式风格编写代码；使得代码精简的同时，可读性更好，表达更清晰。&emsp;&emsp;下面我们来看几个最佳实践 二. 最佳实践1. 简化内部类的写法&emsp;&emsp;熟悉lambda的最快方法是使用lambda表达式替换匿名类，比如构造线程时的Runnable接口 // Java 8之前： new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;Before Java8, too much code for too little to do&quot;); } }).start();//Java 8方式： new Thread( () -&gt; System.out.println(&quot;In Java8, Lambda expression rocks !!&quot;) ).start();2. 集合类的迭代&emsp;&emsp;针对集合类，最常见的操作就是进行循环，并将业务逻辑应用于各个元素。使用Java 8的Lambda表达式对集合做迭代操作简便很多。 // Java 8之前： List features = Arrays.asList(&quot;Lambdas&quot;, &quot;Default Method&quot;, &quot;Stream API&quot;, &quot;Date and Time API&quot;); for (String feature : features) { System.out.println(feature); }// Java 8之后： List features = Arrays.asList(&quot;Lambdas&quot;, &quot;Default Method&quot;, &quot;Stream API&quot;, &quot;Date and Time API&quot;); features.forEach(n -&gt; System.out.println(n)); // 使用Java 8的方法引用更方便，方法引用由::双冒号操作符标示， features.forEach(System.out::println);输出结果： Lambdas Default Method Stream API Date and Time API3. 支持函数编程&emsp;&emsp;为了支持函数编程，Java 8加入了一个新的包java.util.function，其中有一个接口java.util.function.Predicate是支持Lambda函数编程： public static void filter(List names, Predicate condition) { names.stream().filter((name) -&gt; (condition.test(name))) .forEach((name) -&gt; {System.out.println(name + &quot; &quot;); }); } public static void main(args[]){ List languages = Arrays.asList(&quot;Java&quot;, &quot;Scala&quot;, &quot;C++&quot;, &quot;Haskell&quot;, &quot;Lisp&quot;); System.out.println(&quot;Languages which starts with J :&quot;); filter(languages, (str)-&gt;str.startsWith(&quot;J&quot;)); System.out.println(&quot;Languages which ends with a &quot;); filter(languages, (str)-&gt;str.endsWith(&quot;a&quot;)); System.out.println(&quot;Print all languages :&quot;); filter(languages, (str)-&gt;true); System.out.println(&quot;Print no language : &quot;); filter(languages, (str)-&gt;false); System.out.println(&quot;Print language whose length greater than 4:&quot;); filter(languages, (str)-&gt;str.length() &gt; 4); }输出结果： Output: Languages which starts with J : Java Languages which ends with a Java Scala Print all languages : Java Scala C++ Haskell Lisp Print no language : Print language whose length greater than 4: Scala Haskell4. 管道方式的处理&emsp;&emsp;Java 8里面新增的Stream API ，让集合中的数据处理起来更加方便，性能更高，可读性更好。 &emsp;&emsp;假设一个业务场景：对于20元以上的商品，进行9折处理，最后得到这些商品的折后价格。 final BigDecimal totalOfDiscountedPrices = prices.stream() .filter(price -&gt; price.compareTo(BigDecimal.valueOf(20)) &gt; 0) .map(price -&gt; price.multiply(BigDecimal.valueOf(0.9))) .reduce(BigDecimal.ZERO,BigDecimal::add); System.out.println(&quot;Total of discounted prices: &quot; + totalOfDiscountedPrices);&emsp;&emsp;如上例所示，用面向对象处理这些数据，需要多少行、循环，需要声明多少个中间变量。而使用lambda表达式后，可以以极其简洁的代码量完成。","categories":[{"name":"技术","slug":"技术","permalink":"http://ajayhao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://ajayhao.github.io/tags/Java/"}]},{"title":"Java 8 进阶系列 - 新日期/时间库","slug":"java8-new-datetime-lib","date":"2020-02-29T06:17:03.000Z","updated":"2020-02-29T06:17:03.000Z","comments":true,"path":"2020/02/29/java8-new-datetime-lib/","link":"","permalink":"http://ajayhao.github.io/2020/02/29/java8-new-datetime-lib/","excerpt":"","text":"[toc] 一. 前言&emsp;&emsp;Java的老版本中，日期及时间的处理一直以来都饱受诟病，原生API中缺少对于日期的计算、调整的良好支持，需要通过日历工具类（java.util.Calendar，下文简称Calendar类）进行辅助，而日期的格式化与转换需要通过SimpleDateFormat类进行处理。而Java 8之前的迷之设计，例如将java.util.Date（下文简称为Date类）设计为可修改的，以及将Calendar类及SimpleDateFormat类设计成非线程安全的，都使得日期操作在高并发场景中需要格外小心。 &emsp;&emsp;Java 8引入了一套全新的时间日期库，最大的优点就在于它定义清楚了时间日期相关的一些概念，比方说，瞬时时间（Instant）,持续时间（duration），日期（date）,时间（time），时区（time-zone）以及时间段（Period）。同时它也借鉴了Joda库的一些优点，比如将人和机器对时间日期的理解区分开的。Java 8仍然延用了ISO的日历体系，并且与它的前辈们不同，java.time包中的类是不可变且线程安全的。新的时间及日期API位于java.time包中，下面是里面的一些关键的类： Instant——它代表的是时间戳 LocalDate——不包含具体时间的日期，比如2014-01-14。它可以用来存储生日，周年纪念日，入职日期等。 LocalTime——它代表的是不含日期的时间 LocalDateTime——它包含了日期及时间，不过还是没有偏移信息或者说时区。 ZonedDateTime——这是一个包含时区的完整的日期时间，偏移量是以UTC/格林威治时间为基准的。 &emsp;&emsp;新的库还增加了ZoneOffset及ZoneId，可以为时区提供更好的支持。另外，使用了新的格式化类DateTimeFormatter之后，日期的解析及格式化也变得焕然一新了。新赠的Year对象，Month对象也可以更好的用来处理年月的推算和展示，下面我们通过一些实例来瞧一瞧。 二. 场景实例（一）. 向上兼容&emsp;&emsp;大量项目中现存的日期工具类都会使用Date类型作为出入参对象，切换新接口面临最大的问题是接口参数的适配，因此第一步我们先看下Date类型与新日期库类型的转换。基于此，后续的所有场景就可以用新日期库进行处理了。 Instant对象与Date对象互转// Instant对象转Date private static Date from(Instant instant) { return new Date(instant.toEpochMilli()); } // 时间戳转Instant private static Instant toInstant(Long timeMilli) { Date d = new Date(timeMilli); return d.toInstant(); }（二）. 日期、时间对象转换&emsp;&emsp;有了Instant对象后，与LocalDate及LocalDateTime对象的转换就方便多了 Instant对象转LocalDateTime对象Instant instant = new Date().toInstant(); LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault()); System.out.println(&quot;Local datetime : &quot; + localDateTime); //打印结果 Local datetime : 2020-02-23T21:20:14.256LocalDateTime对象转Instant对象LocalDateTime localDateTime = LocalDateTime.now(); Instant instant = localDateTime.atZone(ZoneId.systemDefault()).toInstant(); System.out.println(&quot;instant : &quot; + instant); //打印结果 instant : 2020-02-23T21:30:00ZLocalDateTime对象转LocalDate对象LocalDateTime localDateTime = LocalDateTime.now(); LocalDate localDate = localDateTime.toLocalDate(); System.out.println(&quot;Local date : &quot; + localDate); //打印结果 Local date : 2020-02-23LocalDateTime对象转LocalTime对象LocalDateTime localDateTime = LocalDateTime.now(); LocalTime localTime = localDateTime.toLocalTime(); System.out.println(&quot;Local time : &quot; + localTime); //打印结果 Local time : 21:30（三）. 日期、时间获取当前日期LocalDate today = LocalDate.now(); System.out.println(&quot;Local date : &quot; + today); //打印结果 Local date : 2020-02-23 当前时间LocalTime now = LocalTime.now(); System.out.println(&quot;Local time : &quot; + now); //打印结果 Local time : 21:20:14.256当前日期时间LocalDateTime now = LocalDateTime.now(); // 或者 Instant now = Instant.now(); System.out.println(&quot;Local datetime : &quot; + now); //打印结果 Local datetime : 2020-02-23T21:20:14.256所在年、月、日LocalDate currentDate = LocalDate.now(); System.out.println(&quot;所在年:&quot;+currentDate.getYear()); System.out.println(&quot;所在月:&quot;+currentDate.getMonthValue()); System.out.println(&quot;所在日:&quot;+currentDate.getDayOfMonth()); //打印结果 所在年:2020 所在月:2 所在日:23Long类型的10位秒数、13位毫秒数Instant now = Instant.now(); System.out.println(&quot;秒数:&quot;+now.getEpochSecond()); System.out.println(&quot;毫秒数:&quot;+now.toEpochMilli()); //打印结果 秒数:1582883565 毫秒数:1582883565623根据年月日的值获取LocalDate、LocalDateTimeLocalDate.of(2020, 2, 23); // 2020-02-23 LocalDateTime.of(2020, 2, 23, 10, 30, 0); // 2020-02-23T10:30根据某年的第n天获取LocalDateLocalDate.ofYearDay(2020, 60); // 2020-02-29常用日期时间获取场景LocalDate.now().getYear(); // 年份 LocalDate.now().getMonthValue(); // 月份（数值表示， 从1开始） LocalDate.now().getMonth(); // 月份（英文[enum]表示） LocalDate.now().getDayOfMonth(); // 日期（从1开始） LocalDate.now().getDayOfYear(): // 当天所在这一年的第几天（从1开始） LocalDate.now().getDayOfWeek(); // 星期几 LocalDate.now().lengthOfYear(); // 当年的天数 LocalDate.now().lengthOfMonth(); //当月的天数（四）. 日期推算&emsp;&emsp;此处列示一些常用的场景，实际需求中大多数的场景可通过这些案例灵活组合来搞定。 加法LocalDate localDate = LocalDate.of(2020, 2, 23); localDate.plusDays(1); // 加1天：2020-02-24 localDate.plusWeeks(1); // 加1周：2020-03-01 localDate.plusMonths(1); // 加1月：2020-03-23 localDate.plusYears(1); // 加1年：2021-02-23减法LocalDate localDate = LocalDate.of(2020, 2, 23); localDate.minusDays(1); // 减1天：2020-02-22 localDate.minusWeeks(1); // 减1周：2020-02-16 localDate.minusMonths(1); // 减1月：2020-01-23 localDate.minusYears(1); // 减1年：2019-02-23&emsp;&emsp;加法方法传入负数可同样实现减法效果 普通日期转换&emsp;&emsp;这边的转换指时间日期按照规则计算并返回，并不影响调用对象localDate的原始值 LocalDate localDate = LocalDate.of(2020, 2, 23); localDate.withDayOfMonth(1)); // 转为该月的第1天： 2020-02-01 localDate.withDayOfYear(1)); // 转为该年的第1天： 2020-01-01 localDate.withMonth(1)); // 替换月份为1：2020-01-23 localDate.withYear(2019)); // 替换年份为2019：2019-02-23高级日期转换&emsp;&emsp;高级日期替换需要配合TemporalAdjusters这个类，其提供了自由度更高的替换 &emsp;&emsp;具体用法如下： LocalDate localDate = LocalDate.of(2020, 2, 23); localDate.with(TemporalAdjusters.lastDayOfMonth())); // 该月最后一天：2020-02-29 localDate.with(TemporalAdjusters.firstDayOfNextMonth())); // 下月第一天：2020-03-01 localDate.with(TemporalAdjusters.lastDayOfYear())); // 该年最后一天：2020-12-31&emsp;&emsp;LocalDate的getMonth方法和getDayOfWeek可以分别返回Month和DayOfWeek对象，也有些较实用的方法，比如拿到本季度的第一个月 localDate.getMonth().firstMonthOfQuarter() 虽然返回的也是Month类型，可以通过简单转换提取日期，比如返回所在季度第一天 LocalDate localDate = LocalDate.of(2020, 2, 23); LocalDate.of(localDate.getYear(), localDate.getMonth().firstMonthOfQuarter().getValue(),1) // 该年最后一天：2020-01-01日期的比较&emsp;&emsp;可以对两个 LocalDate 进行比较，可以判断一个日期是否在另一个日期之前或之后，或者判断两个日期是否是同年同月同日。 LocalDate localDate = LocalDate.of(2020, 2, 23); System.out.println(&quot;是否在当天之前：&quot; + localDate.isBefore(LocalDate.now())); System.out.println(&quot;是否在当天之后：&quot; + localDate.isAfter(LocalDate.now())); System.out.println(&quot;是否在当天：&quot; + localDate.isEqual(LocalDate.now())); System.out.println(&quot;今年是否是闰年：&quot; + LocalDate.now().isLeapYear()); //是否在当天之前：true //是否在当天之后：false //是否在当天：false //今年是否是闰年：true（五）. 日期、时间格式化&emsp;&emsp;LocalDate的默认输出格式(即toString())为 yyyy-MM-dd &emsp;&emsp;LocalTime因分钟以下单位的0不自动显示，因此默认输出格式(即toString())为在 HH:mm到HH:mm:ss.SSSSSSSSS之间 &emsp;&emsp;LocalDateTime的默认输出格式则为两者的组合，以T拼接 &emsp;&emsp;使用旧的Date对象时，我们用SimpleDateFormat进行格式化显示。使用新的LocalDateTime或ZonedLocalDateTime时，我们要进行格式化显示，就要使用DateTimeFormatter。 &emsp;&emsp;和SimpleDateFormat不同的是，DateTimeFormatter不但是不变对象，它还是线程安全的。线程的概念我们会在后面涉及到。现在我们只需要记住：因为SimpleDateFormat不是线程安全的，使用的时候，只能在方法内部创建新的局部变量。而DateTimeFormatter可以只创建一个实例，到处引用。 创建DateTimeFormatter时，我们仍然通过传入格式化字符串实现： DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm&quot;);指定格式输出LocalDateTime localDateTime = LocalDateTime.of(2020, 2, 23, 10, 30, 0); DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm&quot;); System.out.println(formatter.format(localDateTime)); // 2020-02-23 10:30指定格式输入&emsp;&emsp;构造指定格式的日期格式对象，是将formatter传给相应日期时间对象的parse方法 String startDateStr = &quot;20200223&quot;; DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;); LocalDate startDate = LocalDate.parse(startDateStr, dateFormatter); System.out.println(startDate); // 2020-02-23 String startTimeStr = &quot;2020-02-23 10:30:00:222&quot;; DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;); LocalDateTime startDateTime = LocalDateTime.parse(startTimeStr, timeFormatter); System.out.println(startDateTime); // 2020-02-23T10:30:00.222月份、星期中文输出&emsp;&emsp;LocalDate的getMonth方法和getDayOfWeek可以分别返回Month和DayOfWeek对象。这两个对象也有些很实用的方法，比如可以指定语言输出的月份与星期 LocalDate localDate = LocalDate.of(2020, 2, 23); localDate.getMonth().getDisplayName(TextStyle.FULL, Locale.CHINA); // 二月 localDate.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.CHINA); // 星期日三. 总结&emsp;&emsp;Java 8日期/时间API是JSR-310的实现，它的实现目标是克服旧的日期时间实现中所有的缺陷，新的日期/时间API的一些设计原则是： 不变性：新的日期/时间API中，所有的类都是不可变的，这对多线程环境有好处。 关注点分离：新的API将人可读的日期时间和机器时间（unix timestamp）明确分离，它为日期（Date）、时间（Time）、日期时间（DateTime）、时间戳（unix timestamp）以及时区定义了不同的类。 清晰：在所有的类中，方法都被明确定义用以完成相同的行为。举个例子，要拿到当前实例我们可以使用now()方法，在所有的类中都定义了format()和parse()方法，而不是像以前那样专门有一个独立的类。为了更好的处理问题，所有的类都使用了工厂模式和策略模式，一旦你使用了其中某个类的方法，与其他类协同工作并不困难。 实用操作：所有新的日期/时间API类都实现了一系列方法用以完成通用的任务，如：加、减、格式化、解析、从日期/时间中提取单独部分，等等。 可扩展性：新的日期/时间API是工作在ISO-8601日历系统上的，但我们也可以将其应用在非ISO的日历上。 &emsp;&emsp;因此新日期/时间API才成为是除Java核心API以外另一项倍受欢迎的内容。","categories":[{"name":"技术","slug":"技术","permalink":"http://ajayhao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://ajayhao.github.io/tags/Java/"}]},{"title":"数据分析可视化工具之 - Echarts","slug":"echarts-demo","date":"2020-02-06T14:14:00.000Z","updated":"2020-02-06T14:14:00.000Z","comments":true,"path":"2020/02/06/echarts-demo/","link":"","permalink":"http://ajayhao.github.io/2020/02/06/echarts-demo/","excerpt":"","text":"&emsp;&emsp;最近开始研究数据分析和数据挖掘，两方面的基本功要夯实，一块是数据建模，另一块是可视化。 现有的可视化工具已经非常丰富，图表构成也非常齐全，很多也支持个性化。 具体的可视化工具比较可参考：有哪些值得推荐的数据可视化工具？ &emsp;&emsp;其实看了知乎各路大神的推荐，心中多少已经有底了。。真正的重剑无锋大巧不工，最值得学的还是Excel啊！ &emsp;&emsp;Echarts加入到apache基金会后，文档方面完善了很多，不但有了更规范的API和教程，也有了每种图表分门别类的数据速查手册，对于快速上手和开发益处多多。 一. 组件（component）1. 组件构成&emsp;&emsp;组件是构成图表的要素，常用的组件有xAxis（直角坐标系 X 轴）、yAxis（直角坐标系 Y 轴）、grid（直角坐标系底板）、angleAxis（极坐标系角度轴）、radiusAxis（极坐标系半径轴）、polar（极坐标系底板）、geo（地理坐标系）、dataZoom（数据区缩放组件）、visualMap（视觉映射组件）、tooltip（提示框组件）、toolbox（工具栏组件）、series（系列）等。 &emsp;&emsp;其中系列是比较特殊的组件，是图表的核心数据展现区域，一个系列中可以包含一到多个图表类型，可进行自定义排布与叠加。分单序列数据与数据集方式。 2. 组件定位&emsp;&emsp;通过grid的位置属性来精确定位图表所在位置 &emsp;&emsp;多个grid 3. 行列映射&emsp;&emsp;使用seriesLayoutBy配置项，改变图表对于行列的理解。 seriesLayoutBy可取值： ‘column’: 默认值。系列被安放到 dataset 的列上面。 ‘row’: 系列被安放到 dataset 的行上面。 // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts2175')); // 指定图表的配置项和数据 var option = { title: { text: '行列映射' }, legend: { left: 100 }, tooltip: {}, dataset: { source: [ ['product', '2012', '2013', '2014', '2015'], ['Matcha Latte', 41.1, 30.4, 65.1, 53.3], ['Milk Tea', 86.5, 92.1, 85.7, 83.1], ['Cheese Cocoa', 24.1, 67.2, 79.5, 86.4] ] }, xAxis: [ {type: 'category', gridIndex: 0}, {type: 'category', gridIndex: 1} ], yAxis: [ {gridIndex: 0}, {gridIndex: 1} ], grid: [ {bottom: '55%'}, {top: '55%'} ], series: [ // 这几个系列会在第一个直角坐标系中，每个系列对应到 dataset 的每一行。 {type: 'bar', seriesLayoutBy: 'row'}, {type: 'bar', seriesLayoutBy: 'row'}, {type: 'bar', seriesLayoutBy: 'row'}, // 这几个系列会在第二个直角坐标系中，每个系列对应到 dataset 的每一列。 {type: 'bar', xAxisIndex: 1, yAxisIndex: 1}, {type: 'bar', xAxisIndex: 1, yAxisIndex: 1}, {type: 'bar', xAxisIndex: 1, yAxisIndex: 1}, {type: 'bar', xAxisIndex: 1, yAxisIndex: 1} ] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); 其他详细教程参考：&emsp;&emsp;下面给出一些基本的图例，具体可参考Echarts官方教程 // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts2645')); // 指定图表的配置项和数据 var option = { title: { text: '折线图堆叠' }, tooltip: { trigger: 'axis' }, legend: { data: ['邮件营销', '联盟广告', '视频广告', '直接访问', '搜索引擎'] }, grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true }, toolbox: { feature: { saveAsImage: {} } }, xAxis: { type: 'category', boundaryGap: false, data: ['周一', '周二', '周三', '周四', '周五', '周六', '周日'] }, yAxis: { type: 'value' }, series: [ { name: '邮件营销', type: 'line', stack: '总量', data: [120, 132, 101, 134, 90, 230, 210] }, { name: '联盟广告', type: 'line', stack: '总量', data: [220, 182, 191, 234, 290, 330, 310] }, { name: '视频广告', type: 'line', stack: '总量', data: [150, 232, 201, 154, 190, 330, 410] }, { name: '直接访问', type: 'line', stack: '总量', data: [320, 332, 301, 334, 390, 330, 320] }, { name: '搜索引擎', type: 'line', stack: '总量', data: [820, 932, 901, 934, 1290, 1330, 1320] } ] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts5620')); // 指定图表的配置项和数据 var option = { title: { text: '未来一周气温变化', subtext: '纯属虚构' }, tooltip: { trigger: 'axis' }, legend: { data: ['最高气温', '最低气温'] }, toolbox: { show: true, feature: { dataZoom: { yAxisIndex: 'none' }, dataView: {readOnly: false}, magicType: {type: ['line', 'bar']}, restore: {}, saveAsImage: {} } }, xAxis: { type: 'category', boundaryGap: false, data: ['周一', '周二', '周三', '周四', '周五', '周六', '周日'] }, yAxis: { type: 'value', axisLabel: { formatter: '{value} °C' } }, series: [ { name: '最高气温', type: 'line', data: [11, 11, 15, 13, 12, 13, 10], markPoint: { data: [ {type: 'max', name: '最大值'}, {type: 'min', name: '最小值'} ] }, markLine: { data: [ {type: 'average', name: '平均值'} ] } }, { name: '最低气温', type: 'line', data: [1, -2, 2, 5, 3, 2, 0], markPoint: { data: [ {name: '周最低', value: -2, xAxis: 1, yAxis: -1.5} ] }, markLine: { data: [ {type: 'average', name: '平均值'}, [{ symbol: 'none', x: '90%', yAxis: 'max' }, { symbol: 'circle', label: { position: 'start', formatter: '最大值' }, type: 'max', name: '最高点' }] ] } } ] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts4140')); // 指定图表的配置项和数据 var option = { title: { text: '共享数据集' }, legend: {}, tooltip: { trigger: 'axis', showContent: false }, dataset: { source: [ ['product', '2012', '2013', '2014', '2015', '2016', '2017'], ['Matcha Latte', 41.1, 30.4, 65.1, 53.3, 83.8, 98.7], ['Milk Tea', 86.5, 92.1, 85.7, 83.1, 73.4, 55.1], ['Cheese Cocoa', 24.1, 67.2, 79.5, 86.4, 65.2, 82.5], ['Walnut Brownie', 55.2, 67.1, 69.2, 72.4, 53.9, 39.1] ] }, xAxis: {type: 'category'}, yAxis: {gridIndex: 0}, grid: {top: '55%'}, series: [ {type: 'line', smooth: true, seriesLayoutBy: 'row'}, {type: 'line', smooth: true, seriesLayoutBy: 'row'}, {type: 'line', smooth: true, seriesLayoutBy: 'row'}, {type: 'line', smooth: true, seriesLayoutBy: 'row'}, { type: 'pie', id: 'pie', radius: '30%', center: ['50%', '25%'], label: { formatter: '{b}: {@2012} ({d}%)' }, encode: { itemName: 'product', value: '2012', tooltip: '2012' } } ] } // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts588')); // 指定图表的配置项和数据 var option = { title: { text: '正负条形图' }, tooltip: { trigger: 'axis', axisPointer: { // 坐标轴指示器，坐标轴触发有效 type: 'shadow' // 默认为直线，可选为：'line' | 'shadow' } }, legend: { data: ['利润', '支出', '收入'] }, grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true }, xAxis: [ { type: 'value' } ], yAxis: [ { type: 'category', axisTick: { show: false }, data: ['周一', '周二', '周三', '周四', '周五', '周六', '周日'] } ], series: [ { name: '利润', type: 'bar', label: { show: true, position: 'inside' }, data: [200, 170, 240, 244, 200, 220, 210] }, { name: '收入', type: 'bar', stack: '总量', label: { show: true }, data: [320, 302, 341, 374, 390, 450, 420] }, { name: '支出', type: 'bar', stack: '总量', label: { show: true, position: 'left' }, data: [-120, -132, -101, -134, -190, -230, -210] } ] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts6658')); // 指定图表的配置项和数据 var option = option = { title: { text: '嵌套饼图' }, tooltip: { trigger: 'item', formatter: '{a} {b}: {c} ({d}%)' }, legend: { orient: 'vertical', top: 30, left: 5, data: ['直达', '营销广告', '搜索引擎', '邮件营销', '联盟广告', '视频广告', '百度', '谷歌', '必应', '其他'] }, series: [ { name: '访问来源', type: 'pie', selectedMode: 'single', radius: [0, '30%'], label: { position: 'inner' }, labelLine: { show: false }, data: [ {value: 335, name: '直达', selected: true}, {value: 679, name: '营销广告'}, {value: 1548, name: '搜索引擎'} ] }, { name: '访问来源', type: 'pie', radius: ['40%', '55%'], label: { formatter: '{a|{a}}{abg|}\\n{hr|}\\n {b|{b}:}{c} {per|{d}%} ', backgroundColor: '#eee', borderColor: '#aaa', borderWidth: 1, borderRadius: 4, // shadowBlur:3, // shadowOffsetX: 2, // shadowOffsetY: 2, // shadowColor: '#999', // padding: [0, 7], rich: { a: { color: '#999', lineHeight: 22, align: 'center' }, // abg: { // backgroundColor: '#333', // width: '100%', // align: 'right', // height: 22, // borderRadius: [4, 4, 0, 0] // }, hr: { borderColor: '#aaa', width: '100%', borderWidth: 0.5, height: 0 }, b: { fontSize: 16, lineHeight: 33 }, per: { color: '#eee', backgroundColor: '#334455', padding: [2, 4], borderRadius: 2 } } }, data: [ {value: 335, name: '直达'}, {value: 310, name: '邮件营销'}, {value: 234, name: '联盟广告'}, {value: 135, name: '视频广告'}, {value: 1048, name: '百度'}, {value: 251, name: '谷歌'}, {value: 147, name: '必应'}, {value: 102, name: '其他'} ] } ] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option);","categories":[{"name":"技术","slug":"技术","permalink":"http://ajayhao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"可视化","slug":"可视化","permalink":"http://ajayhao.github.io/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"echarts","slug":"echarts","permalink":"http://ajayhao.github.io/tags/echarts/"}]},{"title":"中国金融体系指标大全","slug":"index-encyclopedia","date":"2020-01-28T15:09:00.000Z","updated":"2020-01-28T15:09:00.000Z","comments":true,"path":"2020/01/28/index-encyclopedia/","link":"","permalink":"http://ajayhao.github.io/2020/01/28/index-encyclopedia/","excerpt":"","text":"[toc] 一. 央行体系金融指标维度(一) 货币供应1. 货币发行与基础货币（亦称央行储备货币） 货币发行量 = 商业银行的库存现金+ M0 基础货币（央行储备货币）= 货币发行量+法定存款准备金+超额存款准备金 = 商业银行的库存现金+流通中的M0+法定存款准备金+超额存款准备金 银行间市场的可交易资金的总量 = 所有金融机构超额存款准备金合计 &emsp;&emsp;因此，只有影响超额存款准备金的货币政策才能影响到银行体系的流动性。需要说明得是，降准政策只能使得法定存准率和超额存准率此消彼长，对基础货币却几乎没有影响，但央行的公开市场操作等政策可以直接作用于基础外币。 2. M0、M1（狭义货币）与M2（广义货币） M0 = 流通中现金 M1 = M0+企业存款（除单位定期存款和自筹基建存款）+机关团体部队存款+农村存款+个人信用卡类存款 M2 = M1+个人存款+企业定期存款+外币存款+信托类存款。其中，（M2-M1）即为准货币。 (1) 2001年6月，由于股票市场大发展，央行将证券公司客户保证金计入M2。 (2) 2002年，受加入WTO影响，央行将在中国的外资、合资金融机构的人民币存款分别计入不同层次的货币供应量。 (3) 2011年10月，央行将非存款类金融机构在存款类金融机构的存款和住房公积金存款规模纳入M2. (4) 2018年1月，央行用非存款机构部门持有的货币市场基金取代货币市场基金存款（含存单）。 M1、M2的意义: &emsp;&emsp;M1是重要的流动性和经济活跃度指标；M1增加，投资者信心增强，经济活跃度提高，股市和房地产市场上涨；反之，M1减少，股市和房地产市场下跌。 &emsp;&emsp;M1反映了社会的直接购买力，商品的供应量应和M1保持合适的比例关系。 &emsp;&emsp;M2反映现实的购买力，也反映了潜在购买力，掌握其构成变化对整个国民经济状况的分析、预测有重大意义。 &emsp;&emsp;如果M1增速大于M2，意味着企业的活期存款增速大于定期存款增速，企业和居民交易活跃，微观主体盈利能力较强，经济景气度上升。 &emsp;&emsp;如果M1增速小于M2，表明企业和居民选择将资金以定期的形式存在银行，微观个体盈利能力下降，未来可选择的投资机会有限，多余的资金开始从实体经济中沉淀下来，经济运行回落。 3. 存款准备金率与超额备付金率：法定与超额&emsp;&emsp;根据规定，商业银行需要将其存款的一定百分比缴存至央行，即存款准备金率。其中， 存款准备金率 = 法定存款准备金率+超额存款准备金率 超额备付金 = 商业银行在中央银行的超额准备金存款+库存现金 目前央行已经取消了对商业银行备付金率的要求，将其与存准率合二为一。 4. 外汇占款与外汇储备(1) 外汇占款是央行收购外汇资产而相应投放的本国货币，以历史成本计价，更为突出量的层面。 (2) 通常情况下，外汇占款是基础货币的来源，过去很长时间外汇占款贡献了全部基础货币的80%以上，这也是为什么之前较长时期内我国货币供应量无法自主的原因。 (3) 一般而言，央行收购的外汇资产越多，外汇占款规模就越大，而外汇占款后续会进入央行的外汇储备（以市场价计量、基本由国家外管局的投资部门进行统一管理），所以外汇占款与外汇储备之间具有很强的正相关性。 (4) 外汇储备与外汇占款由于计价方式不同，所以二者在整体保持一致的同时，也存在不小的差异。其中外汇储备还将受到汇率变化、利率变化、投资收益以及其它因素的影响，这也是我们看到外汇储备与外汇占款的差异一直存在的背后原因。 5. 银行结售汇(1) 即银行为客户及自身办理的结汇（外汇换成人民币）和售汇（人民币换成外汇）业务，由于商业银行根据每天结售汇的实际发生数据进行汇总后统一报送给外管局，因此这一指标受政策调控的影响较小，更能反应市场变化。 (2) 银行结售汇进一步可分为代客结售汇（更能反映市场情绪和人民币升贬值情况）和自身结售汇（主要反映国际金价的变动），代客结售汇亦可进一步分为即期结售汇和远期结售汇。例如，如果升值则结汇需求会比较大，反则反之。 (3) 即期结售汇主要包括即期结售汇当月发生额、远期结售汇当月履约额、外汇期权当月行权额（目前数据较小、外管局不公布）三大部分。其中，后两个主要反映得是市场主体过去对市场走势的看法。 (4) 考虑到我国为顺差国，因此即期结售汇当月发生额通常应为顺差（结汇大于售汇），那么如果顺差收窄则说明人民币贬值预期较为强烈。 (二) 货币政策工具1. OMO（公开市场操作）(1) 1994年外汇改革的同时，启动了外汇公开市场操作，这也是OMO的起源。 (2) 1998年建立公开市场业务一级交易商制度、恢复人民币公开市场操作。 (3) 公开市场操作又分为逆回购和正回购，前者为央行向一级交易商购买有价证券、投放流动性，后者反则反之。 (4) 目前央行公开市场操作的期限主要有7天、14天、28天和63天等几种类型，但通常主要有7天和14天为主。 2. 再贴现与再贷款(1) 这两类工具是央行最早进行基础货币投放的主要方式（仅次于外汇占款）。 (2) 再贴现政策是指央行通过商业银行持有的已贴现但尚未到期的商业汇票，向商业银行提供融资支持的行为。 (3) 再贷款政策是指央行为实现货币政策目标而对金融机构发放的贷款。1984年央行专门行使中央银行职能后，再贷款成为调控基础货币的基础，并在后续的较长时间提供了基础货币供应总量的70-90%。 3. SLO（短期流动性便利）\\SLF（常备借贷便利）(1) 2013年1月央行创设SLO（Short-term Liquidity Operations），主要为了解决突出的市场资金供求大幅波动，主要期限为7天以内（是7天逆回购工具的补充），抵押品为政府支持机构债券和商业银行债券。 (2) 2013年初创设SLF（StandingLending Facility），主要为了满足金融机构期限较长的大额流动性需求，主要期限为1-3个月，面向政策性银行和全国性商业银行，抵押品为高信用评级的债券类资产及优质信贷资产等。 4. 中国式“利率走廊”&emsp;&emsp;我国“利率走廊”这个概念的提法最早源于2014年5月，由央行行长周小川提出，此后“利率走廊”这个词被频繁使用。但关于“利率走廊”的研究最早可追溯至上世纪90年代。中国“利率走廊”的上限为SLF利率，下限为超额存款准备金利率。通俗理解的话，“利率走廊”上限是商业银行向央妈借钱的利率，下限是商业银行向央妈存钱的利率，利率走廊的区间约为200BP。 &emsp;&emsp;在国外的研究文献中，较早涉及利率走廊操作方法和程序的主要有Kevin Clinton分别完成于1991年和1997年的两篇论文，在其论文中较为细致地描述了利率走廊的实际操作步骤和程序。 5. MLF（中期借贷便利）与TMLF（定向中期借贷便利）(1) 两个工具均主要面向“三农”、小微和民营企业贷款（新增），期限为3个月、6个月、1年（居多）。 (2) 央行分别于2014年9月创设MLF、于2018年12月19日创设TMLF，前者以支持小微企业和债转股为主，后者则用以定向支持金融机构向小微企业和民营企业发放贷款，两个工具的利差为15BP。 6. PSL（抵押补充贷款）&emsp;&emsp;2014年4月25日央行创设PSL（Pledged Supplementary），为特定政策或项目建设提供资金（主要针对棚户区改造），期限通常为3-5年，主要面向政策性银行，抵押资产为高等级债券资产和优质信贷资产等。 7. TLF（临时流动性便利）与CRA（临时准备金动用安排）(1) 2017年1月20日，央行建立了临时流动性便利（TLF，Temporary Lending Facility），为现金投放量较大的几家大型商业银行提供了28天临时流动性支持。 (2) 2017年12月29日，为应对春节期间现金支出的扰动央行建立了临时准备金动用安排，允许现金投放中占比较高的全国性商业银行春节期间存在临时流动性缺口时，临时使用不超过两个百分点的法定存款准备金，使用期限为30天。 8. LPR（Loan Prime Rate，最优惠贷款利率或贷款基础利率）&emsp;&emsp;我国央行2013年10月正式推出LPR，定位于10家银行最优客户贷款利率的平均值（剔除最高和最低水平），在成立后的近六年时间里，LPR始终保持和贷款基准利率一致的公布频率、变化幅度，数值上相当平稳，可以说没有发挥好应有的功能。 &emsp;&emsp;2019年8月17日，央行发布15号公告，推出新LPR，并于8月20日早点9：30推出首期新LPR，一年期和五年期以上LPR分别为4.25%和4.85%。同时LPR的报价行增至18家、发布频率为每月20日早上9：30，且在MLF的基础上加点形成。 9. 离岸央票&emsp;&emsp;2018年9月20日，央行和香港特别行政区金融管理局签署《关于使用债务工具中央结算系统发行中国人民银行票据的合作备忘录》，正式拉开了离岸央票的序幕。2019年8月9日央行发布二季度货币政策执行报告，明确提出后续将建立离岸央票的常态发行机制。至2018年9月以来央行已分别于2018年11月（200亿元）、2019年2月（200亿元）、2019年5月（200亿元）、2019年6月（300亿元）、2019年8月发行了合计1200亿元的离岸央票（离岸人民币规模约为6000亿元人民币）。 10. 存款准备金制度（五档两优）&emsp;&emsp;我国的法定存款准备金制度始于1985年（即各类银行开始成立时），在2008年以前一直采取“一档”模式，即无论金融机构大小、性质、重要性程度如何，均实行统一的法定存款准备金率。 &emsp;&emsp;2007-2008年金融危机后，货币政策当局开始意识到统一的存款准备金率政策难以解决国内经济的结构性问题，也难以达到政策诉求，于是根据金融机构重要性程度、规模大小、性质等设置有差异的存款准备金率，有一档到两档，再到目前的五档两优（银行业为三档两优）。也即政策性银行、国有大行、中小银行、县域农村金融机构、非银金融机构各一档，同时国有大行与中小银行还可以享受普惠金融定向考核政策，而县域农村金融机构则可以根据服务当地情况进一步享受优惠存款准备金率政策。 政策性银行 6家国有大行 中小型商业银行 县城农村金融机构 财务公司、金融租赁公司、汽车金融公司 范围 国开行、进出口银行、农业发展银行 工、农、中、建、交、邮储 12家股份制银行、134家城商行、非县域农商行、民营银行和外资银行 农信社、农村合作银行、村镇银行 五档 执行7.50%的基准存款准备金率 执行12%或13%的基准存款准备金率 执行10%、11%或11.50%的基准存款准备金率 执行7%、8%的基准存款准备金率 执行6%的基准存款准备金率 两优 普惠金融定向降准政策考核：达到一定标准的机构可在相应基准档次上降低0.50个或1.50个百分点的存款准备金率 新增存款一定比例用于当地贷款的政策考核；在基准档次上降低1个百分点的存款准备金率 11. 外汇风险准备金&emsp;&emsp;外汇风险准备金源于2015年8月31央行发布的《关于加强远期售汇宏观审慎管理的通知（银发[2015]273号）》，通知要求从2015年10月15日起，开展代客远期售汇业务的金融机构（含财务公司）应交存外汇风险准备金，准备金率暂定为20%。该规定提高了客户远期购汇成本，有助于调控人民币过度贬值的问题。 &emsp;&emsp;2017年9月央行及时调整前期为抑制外汇市场顺周期波动出台的逆周期宏观审慎管理措施，将外汇风险准备金率调整为0。 (三) 社会融资规模&emsp;&emsp;社会融资规模于2010年提出来，是一个中国独有的指标。所谓社会融资规模，即一定时期内（月度、季度和年度）实体经济从金融体系所获得的资金总额，既有存量概念，又有流量内涵，可兼顾绝对规模，又可衍生相对指标。 &emsp;&emsp;谈及社会融资规模，离不开其兄弟指标M2，社会融资规模与M2类似于一张表的两端，即资产和负债，一个表示资产的运用（社会融资规模），一个表示资金的来源（M2）。通俗来讲，货币当局发行货币（以广义货币M2来表示），金融机构拿到货币来满足实体经济的融资需求，货币则通过银行金融机构（本外币贷款）、非银行金融机构（委托贷款、信托贷款以及未贴现票据）、资本市场（股票市场和债券市场）以及其它等渠道进入实体经济。从理论上来讲，资产的运用和资金的来源应存在一定的对应关系，特别是在只有资本市场的情况下，而间接融资中介的存在，使得这一对应变得比较复杂，因此严格的对应关系并不会存在。简之，社会融资规模可理解为金融体系的资产、实体经济的负债；而M2则可理解为金融体系的负债、央行的资产（央行对国家的负债）。 1. 发展历程(1) 人民银行于2010年11月开始研究、编制社会融资规模指标； (2) 2010年12月，中央经济工作会议首次提出“保持合理的社会融资规模”这一概念； (3) 2011年初，人民银行正式建立社会融资规模增量统计制度，并开始按季向社会公布社会融资规模增量季度数据；2012年起改为按月公布； (4) 2014年起，按季公布各地区（省、自治区、直辖市）社会融资规模增量统计数据； (5) 2015年起，开始编制并按季发布社会融资规模存量数据，2016年起改为按月发布。 2. 口径和范围(1) 金融机构表内贷款：人民币贷款和外币贷款 (2) 金融机构表外贷款：委托贷款、信托贷款和未贴现的银行承兑票据（已贴现的为表内） (3) 直接融资：企业债券和非金融企业境内股票融资 (4) 其它：存款类金融机构资产支持证券、贷款核销与地方政府专项债券。 &emsp;&emsp;第一，2018年8月13日，央行表示，自2018年7月起,人民银行完善社会融资规模统计方法，将“存款类金融机构资产支持证券”和“贷款核销”纳入社会融资规模统计，在“其他融资”项下反映。 &emsp;&emsp;第二，2018年10月17日，央行表示，自2018年9月起，将“地方政府专项债券”纳入社会融资规模统计。 二. 商业银行资产质量维度(一) 五级贷款分类&emsp;&emsp;贷款五级分类是央行于1998年5月参照国际惯例制定《贷款分类指导原则》给予明确的。之前是按照财政部1993年颁布的《金融保险企业财务制度》将贷款分为正常、逾期、呆滞和呆账四类，过去是将后面三种，即“一逾两呆”统称为不良贷款。 1. 正常类贷款（率）(1) 具体是指借款人能够正常履行合同，没有足够理由怀疑其贷款本息不能按时偿还的贷款。 (2) 正常贷款率没有特定监管标准，一般越高越好，基本上正常贷款率（即正常类贷款/全部贷款）均在95%以上。 2. 关注类贷款（率）(1) 具体是指目前有能力偿还贷款本息，但存在一些可能对偿还不利的影响因素的贷款。 (2) 关注贷款介于正常类贷款和不良贷款之间，关注贷款率同样没有特定监管标准。 3. 不良贷款（率）(1) 指那些借款人还款能力出现明显问题的贷款，主要包括次级类贷款、可疑类贷款和损失类贷款三类。其中， &emsp;&emsp;次级类贷款是指还款能力出现明显问题，完全依靠其正常营业收入无法足额偿还贷款本息，即使执行担保，也会造成一定损失的贷款。 &emsp;&emsp;可疑类贷款是指贷款人无法足额偿还贷款本息，即使执行担保，也可能会造成较大损失的贷款。 &emsp;&emsp;损失类贷款是指在采取所有可能的措施或一切必要的法律程序后，本息仍无法收回，或只能收回很少一部分的贷款。 (2) 不良贷款率 = 不良贷款余额/各项贷款余额 = （次级类贷款余额+可疑类贷款余额+损失类贷款余额）/各项贷款余额 = 贷款拨备率/拨备覆盖率。 (3) 不良贷款率也没有特定的监管标准，通常是越低越好，但不良贷款、关注贷款、逾期贷款之间有一定的重合性，从而生成分类上不够严谨。 2005年12月31日发布的《商业银行风险监管核心指标（试行）》规定不良贷款率不得大于5%、不良资产率不得大于4%。这里的不良资产率是指所有不良资产（包括同业端、客户端与投资端）和总资产的比例。 (二) 逾期贷款与重组贷款1. 逾期贷款（率）(1) 贷款项目在贷款合同规定期限内，尚未还清的贷款部分，并从逾期之日起，转入逾期贷款账户，一般情况下逾期贷款要加收较高的惩罚利息。 (2) 逾期贷款按期限进一步划分，即逾期3个月以内、逾期3个月至1年、逾期1年以上至3年以内、逾期3年以上。 (3) 逾期贷款和不良贷款由较高的重合度，且没有特定的监管标准。 2. 重组贷款（率）(1) 所谓重组贷款即由于借款人财务状况恶化，或无力还款而对借款合同条款做出调整的贷款。其中调整措施主要包括贷款展期、借新还旧、还旧借新、利息罚息减免、本金部分减免、债转股、以物抵贷、追加担保品、还款方式变更等。 (2) 逾期贷款按期限进一步划分，即逾期3个月以内、逾期3个月至1年、逾期1年以上至3年以内、逾期3年以上。 (3) 逾期贷款和不良贷款由较高的重合度，且没有特定的监管标准。 (三) 贷款拨备率与拨备覆盖率1. 贷款拨备率（又称拨贷比）贷款拨备率， 即贷款损失准备与各项贷款的比值贷款损失准备与各项贷款的比值。 (1) 贷款拨备率 = 贷款减值准备/各项贷款余额 =（一般准备+特殊准备+专项准备）/各项贷款余额。 (2) 2011年银监会以9号令的形式印发《商业银行贷款损失准备管理办法》，将《银行贷款损失准备计提指引》中的一般准备、专项准备和特别准备统一合并为“贷款损失准备”，并将其在成本中列支，作为抵御贷款风险的准备金。其中， &emsp;&emsp;贷款减值准备计提 = 1%各项贷款余额 + 2%关注类贷款 + 25%次级类贷款 + 50%可疑类贷款 + 100%*损失类贷款 + 特别准备。 &emsp;&emsp;次级类和可疑类贷款的计提比例可以上下浮动20%，特别准备由商业银行根据特别风险情况、风险损失概率及历史经验等自行确定按季计提。 贷款减值准备计提的细项 一般准备 即按照贷款余额的一定比例提取的贷款减值准备，我国商业银行规定的是按1%比例提取，各银行可以自主调高。 专项准备 即根据借款人的还款能力、贷款本息的偿还情况、抵押品的情况、担保人的情况等因素，按照贷款风险分类的结果，以建议的计提比例进行计提。 当然，银行内部还可根据实际情况，做出更细的分类，如七级、十级等。 特别准备 即针对贷款组织中的特定风险，按一定比例提取的，只有遇到特别风险情况时才会计提，并非经常提取 &emsp;&emsp;贷款减值准备期末余额 = 期初余额 + 期初调整 + 当期计提-当期转回 + 当期转入- 已减值贷款折现回拨部分 + 收回以前年度核销部分 - 当期核销 + 其它因素变动。 (3) 2015-2016年业务制度更新，《G11-II资产质量及准备金》将三项准备统一为减值准备。 (4) 中国上市公司的应收账款坏账准备金的提取比率为9%，即按应收账款余额的9%计提坏账准备金，提取的准备金计入当期损益。这里的坏账准备等同减值准备。 (5) 贷款拨备率的监管标准为2.50%。 2. 拨备覆盖率(1) 用来衡量商业银行贷款损失准备金计提是否充足的一个指标，其计算公式为： &emsp;&emsp;拨备覆盖率 = 贷款减值准备/不良贷款。 (2) 一般各家银行贷款减值准备的计提标准不同，因此可比性不高，而计入当期损益的贷款减值准备也是影响业绩的重要因素，因此资产质量与经营业绩之间具有较强的关联性。 (3) 拨备覆盖率的监管标准为150%。 (四) 新口径贷款拨备率与拨备覆盖率&emsp;&emsp;2018年2月28日，银监会发布《关于调整商业银行贷款损失准备监管要求的通知》（银监发（2018）7号文），明确拨备覆盖率监管要求由150%调整至120-150%，贷款拨备率监管要求由2.5%调整为1.5-2.5%。 &emsp;&emsp;根据三类维度的执行情况分别下调监管要求，各级监管部门应综合考虑商业银行贷款分类准确性、处置不良贷款主动性、资本充足率三方面因素，按照孰高原则，确定贷款损失准备最低监管要求。 1. 贷款分类准确性&emsp;&emsp;按照逾期90天以上贷款纳入不良贷款的比例，确定拨备覆盖率和贷款拨备率最低监管要求。 2. 处置不良贷款主动性&emsp;&emsp;按照处置的不良贷款占新形成不良贷款的比例，确定拨备覆盖率和贷款拨备率监管要求。 3. 资本充足性&emsp;&emsp;按照不同类别商业银行的资本充足率情况，确定拨备覆盖率和贷款拨备率最低监管要求。 逾期90天以上贷款纳入不良贷款的比例 拨备覆盖率最低监管要求 贷款拨备率监管要求 100% 120% 1.5% [85%,100%) 130% 1.8% [70%,85%) 140% 2.1% 70%以下 150% 2.5% 处置的不良贷款占新形成不良贷款的比例 拨备覆盖率最低监管要求 贷款拨备率监管要求 90%及以上 120% 1.5% [75%,90%) 130% 1.8% [60%,75%) 140% 2.1% 60%以下 150% 2.5% 资本充足率（系统重要性银行） 资本充足率（非系统重要性银行） 拨备覆盖率最低监管要求 贷款拨备率监管要求 13.5%及以上 12.5%及以上 120% 1.5% [12.5%,13.5%) [11.5%,12.5%) 130% 1.8% [11.5%,12.5%) [10.5%,11.5%) 140% 2.1% 11.5%以下 10.5%以下 150% 2.5% (五) 其他指标1. 贷款迁徙率&emsp;&emsp;在对贷款进行五级分类后，不同类型贷款之间的迁徙也成为了一个值得关注的指标。2005年12月银监会印发的《商业银行风险监管核心指标（试行）》明确贷款风险迁徙指标主要有正常类贷款迁徙率、关注类贷款迁徙率、次级类贷款迁徙主和可疑类贷款迁徙率。而这里的迁徙主要特指下迁，即相对优的贷款类别下迁到更差贷款的比率，没有特定的监管标准。 (1) 正常类贷款迁徙率 = 期初正常类贷款期末转为后四类贷款的余额/期初正常类贷款余额。 (2) 关注类贷款迁徙率 = 期初关注类贷款期末转为不良贷款的余额/期初关注类贷款余额。 (3) 次级类贷款迁徙率 = 期初次级类贷款期末转为可疑类和损失类贷款余额/期初次级类贷款余额。 (4) 可疑类贷款迁徙率 = 期初可级类贷款期末转为损失类贷款余额/期初可疑类贷款余额。 2. 不良贷款生成率(1) 不良贷款生成率 = （本期新增不良贷款余额+本期不良贷款核销）/总贷款余额。 (2) 关注类贷款迁徙率 = 期初关注类贷款期末转为不良贷款的余额/期初关注类贷款余额。 (3) 次级类贷款迁徙率 = 期初次级类贷款期末转为可疑类和损失类贷款余额/期初次级类贷款余额。 (4) 可疑类贷款迁徙率 = 期初可级类贷款期末转为损失类贷款余额/期初可疑类贷款余额。 3. 贷款偏离度(1) 亦称贷款分类偏离度，具体指贷款的账面分类与真实分类的偏差程度，偏离度 = 实际数值/上报数值。 (2) 偏离度一般超过5%即为不正常。 (3) 不良贷款偏离度一般还指90天以上逾期贷款与不良贷款的比例，超过100%即说明分类不准确。 三. 商业银行资本维度(一) 资本类型&emsp;&emsp;该部分内容详见银监会2012年7月发布的《商业银行资本管理办法（试行）》 1. 一级资本（亦称核心资本）所谓核心资本，具体是指商业银行可以永久使用和支配的自有资金。 (1) 一级资本包括核心一级资本和其它一级资本两类。 (2) 核心一级资本包括实收资本、资本公积、盈余公积、一般风险准备、未分配利润、少数股东资本可计入的部分。 (3) 其它一级资本包括永续债、优先股等其它一级资本工具以及少数股东资本可计入的部分。 (4) 一级资本占全部资本总额的比例必须在50%以上。 (5) 一级资本的扣除项应包括： &emsp;&emsp; a). 商誉、其它无形资产（土地使用权除外）、由经营亏损引起的净递延税资产和贷款损失准备缺口； &emsp;&emsp; b). 资产证券化销售利得、确定受益类的养老金资产净额、直接或间接持有本银行的股票； &emsp;&emsp; c). 对资产负债表中未按公允价值计量的项目进行套期形成的现金流储备（正值予以扣除、负值予以加回）； &emsp;&emsp; d). 商业银行自身信用风险变化导致其负债公允价值变化带来的未实现损益。 2. 二级资本（亦称附属资本）(1) 二级资本主要包括次级债、二级资本债、混合资本工具、超额贷款损失准备以及少数股东资本可计入部分等，其中权重法和内部评级法计量信用风险加权资产的，其超额贷款损失准备可计入二级资本，但比例分别不得超过信用风险加权资产的1.25%和0.60%。 (2) 商业银行二级资本工具有确定到期日的，应当在距到期日的最后五年，按100%、80%、80%、60%、40%、20%的比例逐年减计至二级资本。 (二) 风险加权资产风险加权资产包括信用风险加权资产、市场风险加权资产和操作风险加权资产三类。 1. 信用风险加权资产(1) 可采用权重法或内部评级法进行计量，通常情况下中小银行主要采取权重法来计提信用风险加权资产。 (2) 所谓权重法，即首先从表内资产账面价值中扣除相应的减值准备，然后乘以风险权重。表外项目则以名义金额为基础乘以信用转换系数得到等值的表内资产，再按表内资产的方式进行处理计提。 (3) 表内资产的风险计提方式如下： &emsp;&emsp;第一，商业银行持有中央政府、央行、政策性银行债权的风险权重为0，持有中央政府投资的AMC为收购国有银行不良贷款而定向发行的债券风险权重为0。此外，以风险权重为0的金融资产作为质押的债权风险权重也为0. &emsp;&emsp;第二，商业银行对公共部门实体（省级及计划单列市政府、收入源于中央财政的公共部门等）、对其它商业银行原始期限三个月以内（含）、对ABS的债权风险权重为20%，不包括公共部门实体投资的工商企业债权。 &emsp;&emsp;第三，商业银行对我国其它商业银行一般债权的风险权重为25%、次级债权为100%。 &emsp;&emsp;第四，商业银行对一般企业债权的风险权重为100%，对符合条件的小微企业债权风险权重为75%，对工商企业股权投资的风险权重为400%（被动持有或因政策性原因持有）和1250%（其它）。 &emsp;&emsp;第五，商业银行个人住房抵押贷款风险权重为50%（追加贷款为150%）、对个人其它债权的风险权重为75%。 2. 市场风险加权资产(1) 所谓市场风险是指因市场价格（包括利率、汇率、股票价格和商品价格）的不利变动引起的银行表内外业务发生损失的风险。具体包括商业银行交易账户中的利率风险和股票风险，以及全部汇率风险和商品风险。 (2) 商业银行可以采用标准法或内部模型法计量市场风险资本要求。 (3) 市场风险加权资产 = 市场风险资本要求*12.50。 3. 操作风险加权资产(1) 所谓操作风险具体是指由不完善或有问题的内部程序、员工和信息科技系统，以及外部事件所造成损失的风险，包括法律风险，但不包括策略风险和声誉风险。 (2) 商业银行可以采用基本指标法、标准法或高级计量法计量操作风险资本要求。 (3) 操作风险加权资产 = 操作风险资本要求*12.50。 (三) 资本充足指标资本充足指标总共有三个，分别包括资本充足率、一级资本充足率和核心一级资本充足率。其中， 资本充足率 = 资本净额/风险加权资产 = 资本净额/（信用风险加权资产 + 操作风险资本*12.50 + 市场风险资本*12.50） 1. 一般监管标准资本充足率、一级资本充足率与核心一级资本充足率最低分别为8%、6%和5% 2012年我国根据巴塞尔协议III，发布了《商业银行资本管理办法（试行）》，明确了： (1) 核心一级资本包括实收资本（普通股）、资本公积、盈余公积、一般风险准备、未分配利润和少数股东资本可计入部分，且应当扣除商誉、其它无形资产（土地使用权除外）、由经营亏损引起的净递延税资产和贷款损失准备缺口。 (2) 其它一级资本包括其他一级资本工具及其溢价和少数股东资本可计入部分。 (3) 二级资本包括二级资本工具及其溢价和超额贷款损失准备。其中，超额贷款损失准备计入二级资本的比例不得超过信用风险加权资产的1.25%（权重法）或0.6%（内部评级法）。 (4) 核心一级资本充足率、一级资本充足率和资本充足率的最低标准分别为5%、6%和8%。 2. 最终监管标准资本充足率、一级资本充足率与核心一级资本充足率最低分别为10.50%、8.50%和7.50% &emsp;&emsp;此外，资本管理办法还规定在最低要求的基础上，尚需计提2.5%的储备资本、0-2.5%的逆周期资本以及1%的附加资本，且储备资本、逆周期资本与附加资本均由核心一级资本来补充。其中，1%的附加资本只需要系统重要性银行来计提。这意味着我国系统重要性商业银行资本充足率、一级资本充足率和核心一级资本充足率的监管最低标准实际上为11.5%、9.5%和8.50%。非系统重要性商业银行资本充足率、一级资本充足率和核心一级资本充足率的监管最低标准实际上为10.5%、8.5%和7.50%。 &emsp;目前我国正在明确系统重要性金融机构的名单，预计2019年年内将会择时发布，届时1%的附加资本将会产生作用。 3. MPA特别规定宏观审慎资本充足率： &emsp;&emsp;到目前为止，银监会尚没有出台关于逆周期资本的相关细则，所以基本可以忽略。但尽管银监会并未提及，央行的MPA考核中却涉及到逆周期资本这一概念。央行在MPA中提出宏观审慎资本充足率的概念，需要注意得是这里的储备资本与系统重要性附加资本和银监会的口径均不是一个概念。&emsp;&emsp;其中，储备资本由核心一级资本满足（2.5%）、逆周期资本由核心一级资本满足（0-2.5%）。因此核心一级资本充足率、一级资本充足率和资本充足率的实际最低标准应分别为7.5%、8.5%和10.5%。 4. 杠杆率(1) 杠杆率是指商业银行一级资本与调整后的表内外资产余额的比率，其数值越高说明商业银行资本越充足。 (2) 2015年4月银监会对《商业银行杠杆率管理办法》（银监会2011年第3号令）进行修订，发布了《商业银行杠杆率管理办法（修订）》。 (3) 杠杆率的计算公式为一级资本净额/调整后的表内外资产余额。调整后的表内外资产余额 = 调整后的表内资产余额（不包括表内衍生产品和证券融资交易）+ 衍生产品资产余额 + 证券融资交易资产余额 + 调整后的表外项目余额 + 一级资本扣减项。 四、商业银行流动性维度(一) 监管指标1. 流动性覆盖率（LCR，Liquidity Coverage Ratio）(1) 流动性覆盖率 = 优质流动性资产/未来30日内的资金净流出量 (2) 具体规定详见2018年5月25日发布的《商业银行流动性风险管理办法》（银保监会（2018）第3号令）。 (3) 适用于资产规模在2000亿元以上的银行，监管标准为100%。 (4) 本外币的计算方式和监管标准一致。 2. 净稳定资金比率（NSFR，Net Stable Funding Ratio）(1) 净稳定资金比率 = 可用的稳定资金/所需的稳定资金 (2) 具体规定详见2018年5月25日发布的《商业银行流动性风险管理办法》（银保监会（2018）第3号令）。 (3) 适用于资产规模在2000亿元以上的银行，监管标准为100%。 3. 流动性匹配率(1) 流动性匹配率 = 加权资金来源/加权资金运用 (2) 具体规定详见2018年5月25日发布的《商业银行流动性风险管理办法》（银保监会（2018）第3号令）。 (3) 适用于全部银行，监管标准为100%。 (4) 自2020年1月1日起，流动性匹配率按照监管指标执行，在2020年前暂作为监测指标。 4. 优质流动性资产充足率(1) 优质流动性资产充足率 = 优质流动性资产/短期现金净流出 (2) 适用于资产规模在2000亿元以下的银行，监管标准为100%。 (3) 2018年底和2019年6月底前达到80%和100%。 5. 流动性比例(1) 流动性比例 = 流动性资产/流动性负债 (2) 适用于全部银行，本外币的监管标准为25%。 (3) 流动性资产包括现金、黄金、超额准备金存款、一月内到期同业往来款轧差后资产净额、一月内到期债券投资、在国内外二级市场可随时变现债券投资、其他一月内到期可变现资产（剔除不良资产）。 (4) 流动性负债包括活期存款（不含财政性存款）、一月内到期的定期存款（不含政策性存款）、一个月内到期的同业往来负债净额、一月内到期已发行债券、一月内到期应付利息及各种应付款、一月内到期央行借款、其他一月内到期负债。 (二) 监管指标1. 存贷比(1) 存贷比 = 调整后贷款余额/调整后存款余额。 (2) 2015年6月24日，国务院常务会议通过了《中华人民共和国商业银行法修正案（草案）》，删除了存贷比不得超过75%的规定，将其由法定监管指标转为流动性监测指标。 2. 流动性缺口(1) 流动性缺口 = 表内外资产-表内外负债 = 未来各个时间段到期的表内资产（负债）+未来各个时间段到期的表外收入（支出）。 (2) 流动性缺口率 = 未来各个时间段的流动性缺口/相应时间段到期的表内外资产。 3. 核心负债比例(1) 核心负债比例 = 核心负债/总负债。 (2) 核心负债具体是指距到期日三个月以上（含）定期存款和发行债券以及活期存款的稳定部分。 (3) 监管要求核心负债比例不得低于60%。 4. （最大十家）同业融入比例同业融入比例 = （同业拆放 + 同业存放 + 卖出回购 + 委托方同业代付 + 发行同业存单 - 结算性同业存款)/总负债 5. 最大十户存款（贷款）比例最大十家存款（贷款） = 客户存款合计/各项存款（贷款） 6. 单一最大客户贷款占资本净额比例不超过10% 7. 累计外汇敞口头寸占资本净额比例不超过20% 8. 存款偏离度(1) 存款偏离度=（最后一日各项存款-日均存款）/日均存款。 (2) 2018年6月8日银保监会和央行联合发布《关于完善商业银行存款偏离度管理有关事项的通知》（银保监办发（2018）48号），将商业银行月末存款偏离度指标值由3%调整至4%，季末月份与非季末月份采用相同的指标计算。 (3) 同时48号文还明确商业银行不得设立时点性存款规模考评指标，也不得设定以存款市场份额、排名或同业比较为要求的考评指标。 五、商业银行市场风险维度该部分内容主要源于2004年12月29日银监会刚刚成立时发布的《商业银行市场风险管理指引》。 （一）四大风险来源(1) 重定价风险（Repricing Risk）&emsp;&emsp;亦称为期限错配风险，是最主要和最常见的利率风险形式，主要指由于银行资产、负债和表外业务到期期限（就固定利率而言）或重新定价期限（就浮动利率而言）存在差异所产生的风险。资产负债两端定价的不对称性使银行的收益或内在经济价值随着利率的变动而变化。例如，如果银行以短期存款作为长期固定利率贷款的融资来源，当利率上升时，贷款的利息收入是固定的，但存款的利息支出却会随着利率的上升而增加，从而使银行的未来收益减少和经济价值降低。 (2) 收益率曲线风险（Yield Curve Risk）&emsp;&emsp;即收益率曲线的非平行移动，对银行的收益或内在经济价值产生不利影响，从而形成收益率曲线风险，也称为利率期限结构变化风险。例如，若以五年期政府债券的空头头寸为10年期政府债券的多头头寸进行保值，当收益率曲线变陡的时候，虽然上述安排已经对收益率曲线的平行移动进行了保值，但该10年期债券多头头寸的经济价值还是会下降。 (3) 基准风险（Basis Risk）&emsp;&emsp;基准风险是另一种重要的利率风险来源。在利息收入和利息支出所依据的基准利率变动不一致的情况下，虽然资产、负债和表外业务的重新定价特征相似，但因其现金流和收益的利差发生了变化，也会对银行的收益或内在经济价值产生不利影响。&emsp;&emsp;例如，一家银行用一年期的存款为来源发放一年期的贷款，虽然由于利率敏感性负债与利率敏感性资产的重新定价期限完全相同而不存在重新定价风险，但因为其基准利率的变化可能不完全相关，变化不同步，仍然会使该银行面临着因基准利率的利差发生变化而带来的基准风险。 (4) 期权性风险（Optionality）&emsp;&emsp;期权性风险来源于银行资产、负债和表外业务中所隐含的期权。期权可以是单独的金融工具，如场内（交易所）交易期权和场外期权合同，也可以隐含于其他的标准化金融工具之中，如债券或存款的提前兑付、贷款的提前偿还等选择性条款。&emsp;&emsp;一般而言，期权和期权性条款都是在对买方有利而对卖方不利时执行，因此，此类期权性工具因具有不对称的支付特征而会给卖方带来风险。比如，若利率变动对存款人或借款人有利，存款人就可能选择重新安排存款，借款人可能选择重新安排贷款，从而对银行产生不利影响。 （二）缺口分析（GapAnalysis）&emsp;&emsp;缺口分析是衡量利率变动对银行当期收益的影响的一种方法。具体而言，就是将银行的所有生息资产和付息负债按照重新定价的期限划分到不同的时间段（如1个月以下，13个月，3个月1年，1~5年，5年以上等）。在每个时间段内，将利率敏感性资产减去利率敏感性负债，再加上表外业务头寸，就得到该时间段内的重新定价“缺口”。以该缺口乘以假定的利率变动，即得出这一利率变动对净利息收入变动的大致影响。 &emsp;&emsp;当某一时段内的负债大于资产（包括表外业务头寸）时，就产生了负缺口，即负债敏感型缺口，此时市场利率上升会导致银行的净利息收入下降。相反，当某一时段内的资产（包括表外业务头寸）大于负债时，就产生了正缺口，即资产敏感型缺口，此时市场利率下降会导致银行的净利息收入下降。 &emsp;&emsp;缺口分析中的假定利率变动可以通过多种方式来确定，如历史经验、银行管理层的判断和模拟潜在的未来利率变动等。缺口分析也存在如下缺点：(1) 忽略了同一时段内不同头寸的到期时间或利率重新定价期限的差异。在同一时间段内的加总程度越高，对计量结果精确性的影响就越大。(2) 只考虑了由重新定价期限的不同而带来的利率风险，即重新定价风险，未考虑当利率水平变化时，因各种金融产品基准利率的调整幅度不同而带来的利率风险，即基准风险。同时，缺口分析也未考虑因利率环境改变而引起的支付时间的变化，即忽略了与期权有关的头寸在收入敏感性方面的差异。(3) 非利息收入和费用是银行当期收益的重要来源，但大多数缺口分析未能反映利率变动对非利息收入和费用的影响。第四，缺口分析主要衡量利率变动对银行当期收益的影响，未考虑利率变动对银行经济价值的影响，所以只能反映利率变动的短期影响。因此，缺口分析只是一种初级的、粗略的利率风险计量方法。 （三）久期分析（DurationAnalysis）&emsp;&emsp;久期分析也称为持续期分析或期限弹性分析，是衡量利率变动对银行经济价值影响的一种方法。具体而言，就是对各时段的缺口赋予相应的敏感性权重，得到加权缺口，然后对所有时段的加权缺口进行汇总，以此估算某一给定的小幅（通常小于1%）利率变动可能会对银行经济价值产生的影响（用经济价值变动的百分比表示）。各个时段的敏感性权重通常是由假定的利率变动乘以该时段头寸的假定平均久期来确定。 &emsp;&emsp;当然银行可以对以上的标准久期分析法进行演变，如可以不采用对每一时段头寸使用平均久期的做法，而是通过计算每项资产、负债和表外头寸的精确久期来计量市场利率变化所产生的影响，从而消除加总头寸/现金流量时可能产生的误差。另外，银行还可以采用有效久期分析法，即对不同的时段运用不同的权重，根据在特定的利率变化情况下，假想金融工具市场价值的实际百分比变化，来设计各时段风险权重，从而更好地反映市场利率的显著变动所导致的价格的非线性变化。 &emsp;&emsp;久期分析也存在一定的局限性： (1) 如果在计算敏感性权重时对每一时段使用平均久期，即采用标准久期分析法，久期分析仍然只能反映重新定价风险，不能反映基准风险，以及因利率和支付时间的不同而导致的头寸的实际利率敏感性差异，也不能很好地反映期权性风险。 (2) 对于利率的大幅变动（大于1％），由于头寸价格的变化与利率的变动无法近似为线性关系，降低了久期分析的准确性。 （四）外汇敞口分析（ForeignCurrency Exposure Analysis）&emsp;&emsp;外汇敞口分析是衡量汇率变动对银行当期收益的影响的一种方法。外汇敞口主要来源于银行表内外业务中的货币错配。当在某一时段内，银行某一币种的多头头寸与空头头寸不一致时，所产生的差额就形成了外汇敞口。在存在外汇敞口的情况下，汇率变动可能会给银行的当期收益或经济价值带来损失，从而形成汇率风险。在进行敞口分析时，银行应当分析单一币种的外汇敞口，以及各币种敞口折成报告货币并加总轧差后形成的外汇总敞口。对单一币种的外汇敞口，银行应当分析即期外汇敞口、远期外汇敞口和即期、远期加总轧差后的外汇敞口。银行还应当对交易业务和非交易业务形成的外汇敞口加以区分。对因存在外汇敞口而产生的汇率风险，银行通常采用套期保值和限额管理等方式进行控制。外汇敞口限额包括对单一币种的外汇敞口限额和外汇总敞口限额。外汇敞口分析是银行业较早采用的汇率风险计量方法，具有计算简便、清晰易懂的优点。但是，外汇敞口分析也存在一定的局限性，主要是忽略了各币种汇率变动的相关性，难以揭示由于各币种汇率变动的相关性所带来的汇率风险。 （五）敏感性分析（SensitivityAnalysis）&emsp;&emsp;敏感性分析是指在保持其他条件不变的前提下，研究单个市场风险要素（利率、汇率、股票价格和商品价格）的变化可能会对金融工具或资产组合的收益或经济价值产生的影响。巴塞尔委员会在2004年发布的《利率风险管理与监管原则》中，要求银行评估标准利率冲击（如利率上升或下降200个基点）对银行经济价值的影响，也是一种利率敏感性分析方法，目的是使监管当局能够根据标准利率冲击的评估结果，评价银行的内部计量系统是否能充分反映其实际利率风险水平及其资本充足程度，并对不同机构所承担的利率风险进行比较。 &emsp;&emsp;敏感性分析计算简单且便于理解，在市场风险分析中得到了广泛应用。但是敏感性分析也存在一定的局限性，主要表现在对于较复杂的金融工具或资产组合，无法计量其收益或经济价值相对市场风险要素的非线性变化。因此，在使用敏感性分析时要注意其适用范围，并在必要时辅以其他的市场风险分析方法。 （六）情景分析（ScenarioAnalysis）&emsp;&emsp;与敏感性分析对单一因素进行分析不同，情景分析是一种多因素分析方法，结合设定的各种可能情景的发生概率，研究多种因素同时作用时可能产生的影响。在情景分析过程中要注意考虑各种头寸的相关关系和相互作用。情景分析中所用的情景通常包括基准情景、最好的情景和最坏的情景。情景可以人为设定（如直接使用历史上发生过的情景），也可以从对市场风险要素历史数据变动的统计分析中得到，或通过运行描述在特定情况下市场风险要素变动的随机过程得到。如银行可以分析利率、汇率同时发生变化时可能会对其市场风险水平产生的影响，也可以分析在发生历史上出现过的政治、经济事件或金融危机以及一些假设事件时，其市场风险状况可能发生的变化。 （七）风险价值（Value at Risk，VaR）&emsp;&emsp;风险价值是指在一定的持有期和给定的置信水平下，利率、汇率等市场风险要素发生变化时可能对某项资金头寸、资产组合或机构造成的潜在最大损失。例如，在持有期为1天、置信水平为99％的情况下，若所计算的风险价值为1万美元，则表明该银行的资产组合在1天中的损失有99％的可能性不会超过1万美元。风险价值通常是由银行的市场风险内部定量管理模型来估算。 &emsp;&emsp;目前常用的风险价值模型技术主要有三种：方差－协方差法（Variance-Covariance Method）、历史模拟法（HistoricalSimulation Method）和蒙特卡洛法（Monte Carlo Simulation Method）。 &emsp;&emsp;巴塞尔委员会在1996年的《资本协议市场风险补充规定》中对市场风险内部模型主要提出了以下定量要求：置信水平采用99％的单尾置信区间；持有期为10个营业日；市场风险要素价格的历史观测期至少为一年；至少每三个月更新一次数据。但是，在模型技术方面，巴塞尔委员会和各国监管当局均未做出硬性要求，允许银行自行选择三种常用模型技术中的任何一种。即使是对VaR模型参数设置做出的定量规定，也仅限于在计算市场风险监管资本时遵循，商业银行实施内部风险管理完全可以选用不同的参数值。如巴塞尔委员会要求计算监管资本应采用99%的置信水平，而不少银行在内部管理时却选用95%、97.5%的置信水平。此外，考虑到市场风险内部模型本身存在的一些缺陷，巴塞尔委员会要求在计算市场风险监管资本时，必须将计算出来的风险价值乘以一个乘数因子（multiplication factor），使所得出的资本数额足以抵御市场发生不利变化可能对银行造成的损失。乘数因子一般由各国监管当局根据其对银行风险管理体系质量的评估自行确定，巴塞尔委员会规定该值不得低于3。 &emsp;&emsp;市场风险内部模型法也存在一定的局限性。第一，市场风险内部模型计算的风险水平高度概括，不能反映资产组合的构成及其对价格波动的敏感性，因此对具体的风险管理过程作用有限，需要辅之以敏感性分析、情景分析等非统计类方法。第二，市场风险内部模型方法未涵盖价格剧烈波动等可能会对银行造成重大损失的突发性小概率事件，因此需要采用压力测试对其进行补充。第三，大多数市场风险内部模型只能计量交易业务中的市场风险，不能计量非交易业务中的市场风险。因此，使用市场风险内部模型的银行应当充分认识其局限性，恰当理解和运用模型的计算结果。 （八）事后检验（Back Testing）&emsp;&emsp;事后检验是指将市场风险计量方法或模型的估算结果与实际发生的损益进行比较，以检验计量方法或模型的准确性、可靠性，并据此对计量方法或模型进行调整和改进的一种方法。若估算结果与实际结果近似，则表明该风险计量方法或模型的准确性和可靠性较高；若两者差距较大，则表明该风险计量方法或模型的准确性和可靠性较低，或者是事后检验的假设前提存在问题；介于这两种情况之间的检验结果，则暗示该风险计量方法或模型存在问题，但结论不确定。目前，事后检验作为检验市场风险计量方法或模型的一种手段还处在发展过程中。不同银行采用的事后检验方法以及对事后检验结果的解释标准均有所不同。 &emsp;&emsp;巴塞尔委员会1996年的《资本协议市场风险补充规定》要求采用内部模型计算市场风险资本的银行对模型进行事后检验，以检验并提高模型的准确性和可靠性。监管当局应根据事后检验的结果决定是否通过设定附加因子（plus factor）来提高市场风险的监管资本要求。附加因子设定在最低乘数因子（巴塞尔委员会规定为3）之上，取值在01之间。如果监管当局对模型的事后检验结果比较满意，模型也满足了监管当局规定的其他定量和定性标准，就可以将附加因子设为0，否则可以设为01之间的一个数，即通过增大所计算VaR值的乘数因子，对内部模型存在缺陷的银行提出更高的监管资本要求。 （九）压力测试（StressTesting）&emsp;&emsp;银行不仅应采用各种市场风险计量方法对在一般市场情况下所承受的市场风险进行分析，还应当通过压力测试来估算突发的小概率事件等极端不利情况可能对其造成的潜在损失，如在利率、汇率、股票价格等市场风险要素发生剧烈变动、国内生产总值大幅下降、发生意外的政治和经济事件或者几种情形同时发生的情况下，银行可能遭受的损失。压力测试的目的是评估银行在极端不利情况下的亏损承受能力，主要采用敏感性分析和情景分析方法进行模拟和估计。 &emsp;&emsp;在运用敏感性分析方法进行压力测试时，需要回答的问题如：汇率冲击对银行净外汇头寸的影响，利率冲击对银行经济价值或收益产生的影响等等。在运用情景分析方法进行压力测试时，应当选择可能对市场风险产生最大影响的情景，包括历史上发生过重大损失的情景（如1997年的亚洲金融危机）和假设情景。假设情景又包括模型假设和参数不再适用的情形、市场价格发生剧烈变动的情形、市场流动性严重不足的情形，以及外部环境发生重大变化、可能导致重大损失或风险难以控制的情景。这些情景或者由监管当局规定，或者由商业银行根据自己的资产组合特点来设计。在设计压力情景时，既要考虑市场风险要素变动等微观因素，又要考虑一国经济结构和宏观经济政策变化等宏观层面因素。 （十）银行账户与交易账户（BankingBook and TradingBook）&emsp;&emsp;银行的表内外资产可分为银行账户和交易账户资产两大类。巴塞尔委员会2004年的《新资本协议》对其1996年《资本协议市场风险补充规定》中的交易账户定义进行了修改，修改后的定义为：交易账户记录的是银行为交易目的或规避交易账户其他项目的风险而持有的可以自由交易的金融工具和商品头寸。记入交易账户的头寸必须在交易方面不受任何条款限制，或者能够完全规避自身风险。而且，银行应当对交易账户头寸经常进行准确估值，并积极管理该项投资组合。为交易目的而持有的头寸是指，在短期内有目的地持有以便转手出售、从实际或预期的短期价格波动中获利或者锁定套利（lock in arbitrage profits）的头寸，如自营头寸、代客买卖头寸和做市交易（market making）形成的头寸。记入交易账户的头寸应当满足以下基本要求：一是具有经高级管理层批准的书面的头寸/金融工具和投资组合的交易策略（包括持有期限）；二是具有明确的头寸管理政策和程序；三是具有明确的监控头寸与银行交易策略是否一致的政策和程序，包括监控交易规模和交易账户的头寸余额。是否具有交易目的在交易之初就已确定，此后一般不能随意更改。与交易账户相对应，银行的其他业务归入银行账户，最典型的是存贷款业务。交易账户中的项目通常按市场价格计价（mark-to-market），当缺乏可参考的市场价格时，可以按模型定价（mark-to-model）。按模型定价是指将从市场获得的其他相关数据输入模型，计算或推算出交易头寸的价值。银行账户中的项目则通常按历史成本计价。 &emsp;&emsp;商业银行应当制定关于账户划分的内部政策和程序，内容应包括：对交易业务的界定，应列入交易账户的金融工具，对交易和非交易岗位及其职责的严格划分，金融工具或投资组合的交易策略，交易头寸的管理政策和程序，监控交易头寸与交易策略是否一致的程序等。同时，银行应保留完整的交易和账户划分记录，以便进行查询，并接受内部、外部审计和监管当局的监督检查。同时，商业银行应当根据银行账户和交易账户的性质和特点，采取相应的市场风险识别、计量、监测和控制方法。 &emsp;&emsp;另外，划分银行账户和交易账户，也是准确计算市场风险监管资本的基础。巴塞尔委员会于1996年1月颁布的《资本协议市场风险补充规定》以及大多数国家据此制定的资本协议将市场风险纳入了资本要求的范围，但未涵盖全部的市场风险，所包括的是在交易账户中的利率和股票价格风险以及在银行和交易账户中的汇率和商品价格风险。因此，若账户划分不当，会影响市场风险资本要求的准确程度；若银行在两个账户之间随意调节头寸，则会为其根据需要调整所计算的资本充足率提供监管套利机会。目前，实行市场风险监管资本要求的国家/地区的银行监管当局都制定了银行账户、交易账户划分的基本原则，并要求商业银行据此制定内部的政策和程序，详细规定账户划分标准和程序。监管当局则定期对银行的账户划分情况进行检查，检查重点是其内部账户划分的政策、程序是否符合监管当局的要求，是否遵守了内部的账户划分政策和程序，是否为减少监管资本要求而人为地在两个账户之间调节头寸等。 （十一）限额（Limits）管理&emsp;&emsp;商业银行实施市场风险管理，应当确保将所承担的市场风险控制在可以承受的合理范围内，使市场风险水平与其风险管理能力和资本实力相匹配，限额管理正是对市场风险进行控制的一项重要手段。银行应当根据所采用的市场风险计量方法设定市场风险限额。市场风险限额可以分配到不同的地区、业务单元和交易员，还可以按资产组合、金融工具和风险类别进行分解。银行负责市场风险管理的部门应当监测对市场风险限额的遵守情况，并及时将超限额情况报告给管理层。常用的市场风险限额包括交易限额、风险限额和止损限额等。 &emsp;&emsp;交易限额（Limits onNet and Gross Positions）是指对总交易头寸或净交易头寸设定的限额。总头寸限额对特定交易工具的多头头寸或空头头寸给予限制，净头寸限额对多头头寸和空头头寸相抵后的净额加以限制。在实践中，银行通常将这两种交易限额结合使用。 &emsp;&emsp;风险限额是指对按照一定的计量方法所计量的市场风险设定的限额，如对内部模型计量的风险价值设定的限额（Value-at-Risk Limits）和对期权性头寸设定的期权性头寸限额（Limitson Options Positions）等。期权性头寸限额是指对反映期权价值的敏感性参数设定的限额，通常包括：对衡量期权价值对基准资产价格变动率的Delta、衡量Delta对基准资产价格变动率的Gamma、衡量期权价值对市场预期的基准资产价格波动性的敏感度的Vega、衡量期权临近到期日时价值变化的Theta以及衡量期权价值对短期利率变动率的Rho设定的限额。 &emsp;&emsp;止损限额（Stop-LossLimits）即允许的最大损失额。通常，当某项头寸的累计损失达到或接近止损限额时，就必须对该头寸进行对冲交易或将其变现。典型的止损限额具有追溯力，即止损限额适用于一日、一周或一个月内等一段时间内的累计损失。 （十二）按经风险调整的收益率（Risk-Adjusted Rate of Return）&emsp;&emsp;长期以来，衡量企业盈利能力普遍采用的是股本收益率（ROE）和资产收益率（ROA）指标，其缺陷是只考虑了企业的账面盈利而忽略了未充分考虑风险因素。银行是经营特殊商品的高风险企业，以不考虑风险因素的指标衡量其盈利能力，具有很大的局限性。目前，国际银行业的发展趋势是采用按经风险调整的收益率，综合考核银行的盈利能力和风险管理能力。按经风险调整的收益率克服了传统绩效考核中盈利目标未充分反映风险成本的缺陷，使银行的收益与风险直接挂钩、有机结合，体现了业务发展与风险管理的内在统一，实现了经营目标与绩效考核的统一。使用按经风险调整的收益率，有利于在银行内部建立良好的激励机制，从根本上改变银行忽视风险、盲目追求利润的经营方式，激励银行充分了解所承担的风险并自觉地识别、计量、监测和控制这些风险，从而在审慎经营的前提下拓展业务、创造利润。 &emsp;&emsp;在按经风险调整的收益率中，目前被广泛接受和普遍使用的是按经风险调整的资本收益率（Risk-Adjusted Return on Capital，RAROC）。按经风险调整的资本收益率是指经预期损失（Expected Loss，EL）和以经济资本（Capital at Risk，CaR）计量的非预期损失（ Unexpected Loss，UL）调整后的收益率，其计算公式如下： RAROC = （收益－预期损失）/ 经济资本（或非预期损失） &emsp;&emsp;经风险调整的收益率，如RAROC强调，银行承担风险是有成本的。在RAROC计算公式的分子项中，风险带来的预期损失被量化为当期成本，直接对当期盈利进行扣减，以此衡量经风险调整后的收益；在分母项中，则以经济资本，或非预期损失代替传统ROE指标中的所有者权益，意即银行应为不可预计的风险提取相应的经济资本。整个公式衡量的是经济资本的使用效益。 &emsp;&emsp;目前，RAROC等按经风险调整的收益率已在国际先进银行中得到了广泛运用，在其内部各个层面的经营管理活动中发挥着重要作用。在单笔业务层面上，RAROC可用于衡量一笔业务的风险与收益是否匹配，为银行决定是否开展该笔业务以及如何进行定价提供依据。在资产组合层面上，银行在考虑单笔业务的风险和资产组合效应之后，可依据RAROC衡量资产组合的风险与收益是否匹配，及时对RAROC指标呈现明显不利变化趋势的资产组合进行处理，为效益更好的业务腾出空间。在银行总体层面上，RAROC可用于目标设定、业务决策、资本配置和绩效考核等。高级管理层在确定银行能承担的总体风险水平，即风险偏好之后，计算银行需要的总体经济资本，以此评价自身的资本充足状况；将经济资本在各类风险、各个业务部门和各类业务之间进行分配（资本配置），以有效控制银行的总体风险，并通过分配经济资本优化资源配置；同时，将股东回报要求转化为对全行、各业务部门和各个业务线的经营目标，用于绩效考核，使银行实现在可承受风险水平之下的收益最大化，并最终实现股东价值的最大化。 六、商业银行盈利维度（一）净利差与净息差1. 净利差（NIS）净利差 = 生息资产的平均利率 - 计息负债的平均利率。 2. 净息差（NIM，Net Interest Margin）净息差（亦称净利息收益率）= 利息净收入/生息资产平均余额。可以进一步推出： 净息差（NIM）= 净利差（NIS）+ 计息负债的平均利率 * （1 - 计息负债/生息资产） 也即，当负债端成本抬升时，净息差与净利差之间的缺口会被拉大，由于净息差在考虑了规模因素的同时，又融入了结构因素和市场因素，因此净息差往往比净利差具备更高的分析价值。 （二）ROA与ROE1. ROA（资产收益率）ROA = 净利润/资产余额 * 100%。 2. ROE（资本收益率）(1) 又称净资产收益率，即 ROE = 净利润/净资产余额。 (2) 净资产收益率可以分为加权平均净资产收益率和摊薄净资产收益率，其中 &emsp;&emsp;a) 加权平均净资产收益率 = 2 * 净利润/（期末净资产 + 期初净资产） &emsp;&emsp;b) 摊薄净资产收益率 = 2 * 净利润/期末净资产 3. 成本收入比成本收入比 = 业务及管理费用/营业收入，一般越低越好。 4. 信贷成本信贷成本 = 当期信贷拨备/当期平均贷款余额（含贴现）。 2005年12月31日发布的《商业银行风险监管核心指标（试行）》，明确规定成本收入比不得高于35%、资产利润率不得小于0.60%、资本利润率不得小于11%。 七、商业银行集中度管理与大额风险暴露（一）集中度与关联度2005年12月31日，银监会印发了《商业银行风险监管核心指标（试行）》，规定了三个目前仍在使用的监管指标，可以和大额风险暴露规定融合在一起。 1. 单一集团客户授信集中度（小于等于15%）(1) 计算公式为单一集团客户授信集中度＝最大一家集团客户授信总额／资本净额×100% (2) 最大一家集团客户授信总额是指报告期末授信总额最高的一家集团客户的授信总额。 (3) 授信是指商业银行向非金融机构客户直接提供的资金，或者对客户在有关经济活动中可能产生的赔偿、支付责任做出的保证，包括贷款、贸易融资、票据融资、融资租赁、透支、各项垫款等表内业务，以及票据承兑、开出信用证、保函、备用信用证、信用证保兑、债券发行担保、借款担保、有追索权的资产销售、未使用的不可撤销的贷款承诺等表外业务。 2. 单一客户贷款集中度（小于等于10%）(1) 计算公式为单一客户贷款集中度＝最大一家客户贷款总额／资本净额×100% (2) 最大一家客户贷款总额是指报告期末各项贷款余额最高的一家客户的各项贷款的总额。 (3) 客户是指取得贷款的法人、其他经济组织、 个体工商户和自然人。 (3) 各项贷款的定义与不良贷款率指标中定义一致。 3. 全部关联度（小于等于50%）(1) 计算公式为全部关联度＝全部关联方授信总额／资本净额×100% (2) 全部关联方授信总额是指商业银行全部关联方的授信余额，扣除授信时关联方提供的保证金存款以及质押的银行存单和国债金额。 （二）大额风险暴露1. 主要释义该部分内容详见2018年5月4日发布的《商业银行大额风险管理办法》（银保监会（2018）第1号令）。其中， (1) 风险暴露是指商业银行对单一客户或一组关联客户的信用风险暴露,包括银行账簿和交易账簿内各类信用风险暴露。 (2) 大额大风险暴露是指商业银行对单一客户或一组关联客户超过其一级资本净额2.5%的风险暴露。 2. 针对非同业客户(1) 单一客户：贷款余额/资本净额&lt;=10%、风险暴露/一级资本净额&lt;=15% (2) 关联客户：集团客户授信总额/资本净额&lt;=15%、风险暴露/一级资本净额&lt;=20% (3) 针对同业客户和不合格中央交易对手：风险暴露/一级资本净额&lt;=25%此外，同业业务目前还有以下约束，即同业负债占比不超过1/3；以及回购余额不超过上季度净资产的80%。 (4) 全球系统重要性银行与合格中央交易对手 &emsp;&emsp;a)全球系统重要性银行：风险暴露/一级资本净额&lt;=15% &emsp;&emsp;b)合格中央交易对手：清算风险暴露/一级资本净额&lt;= 25% 八、商业银行宏观审慎管理与银行业压力测试&emsp;&emsp;2008年四万亿之后，央行提出差别准备金动态调整和合意贷款管理来约束商业银行的信贷投放。2015年12月29日，人民银行召开会议，部署改进合意贷款管理，从2016年开始实施宏观审慎评估有关工作，央行在此基础上进一步推出MPA考核体系（即宏观审慎评估体系，Macro Prudential Assessment），并于2016年正式实施，随后不断扩充MPA考核范围。 （一）MPA评估体系&emsp;&emsp;MPA指标体系总共包括七大维度、14个指标。 七大维度（各100分） 十四个指标 评分 A档 B档 C档 资本和杠杆情况 资本充足率（80分）、杠杆率（20分）、总损失吸收能力（暂不纳入） 七大方面均为优秀（90分） 其余 任意一项不达标（达标线60分） 定价行为 利率定价（100分） 资产负债情况 广义信贷（60分）、委托信贷（15分）、同业负债（25分） 任意两项不达标（达标线60分） 流动性 流动性覆盖率（40分）、净稳定资金比例（40分）、遵守准备金制度情况（20分） 资产质量 不良贷款率（50分）、拨备覆盖率（50分） 外债风险 外债风险加权余额（100分） 信贷政策执行 信贷执行情况（70分）、央行资金运用情况（30分） 激励约束机制 (1) A档机构执行最优激励，并实施奖励性利率，法定准备金利率上浮10%-30%； (2) B档机构保持不变，继续保持法定准备金利率； (3) C档机构给予适当约束，并实施约束性利率，法定准备金利率视情况下降10%-30%； （二）MPA评分标准 指标体系内（括号内为分值） 评分标准 全国性重要机构（N-SIFIs） 区域性系统重要性机构（R-SIFIs） 普通机构（CFIs） 资本和杠杆情况 资本充足率（80分） (1) &gt;=C*: 80分；(2) (C*-4%, C*): 48-80分；(3) [0%, C*-4%]: 0分 杠杆率（20分） (1) &gt;=4%: 20分；(2) [0%, 4%]: 0分 杠杆率（20分） 监管要求明确前暂不纳入 资产负债情况 广义信贷（60分）：与目标M2增速偏离的百分点相比 (1) &lt;20: 60分 (2) &gt;=20: 0分 (1) &lt;22: 60分 (2) &gt;=22: 0分 (1) &lt;25: 60分 (2) &gt;=25: 0分 委托贷款（15分）：与目标M2增速偏离的百分点相比 (1) &lt;20: 15分 (2) &gt;=20: 0分 (1) &lt;22: 15分 (2) &gt;=22: 0分 (1) &lt;25: 15分 (2) &gt;=25: 0分 同业负债（25分）：与占总负债比例相比 &lt;25: 25分 &lt;28: 25分 &lt;30: 25分 (1) &lt;33: 15-25分；(2) &gt;=33: 0分 流动性 流动性覆盖率（40分） (1) 符合期间监管指标：40分；(2) 不符合：0分 净稳定资金比例（40分） (1) &gt;=100：40分；(2) 其他：0分 遵守准备金制度情况（20分） (1) 遵守：20分；(2) 未遵守：0分 定价行为 利率定价（100分） 利率定价行为符合市场竞争秩序等要求：0-100分 资产质量 不良贷款率（50分） (1) 不高于同地区、同类型机构不良贷款率：50分； (2) 不高于同地区、同类型机构不良贷款率2个百分点且不高于5%： 30-50分； (3) 其他：0分 拨备覆盖率（50分） (1) &gt;=150%：50分；(2) [100%, 150%)：0分 外债风险 外债风险加权全额（100分） (1) 不超过上限：100分；(2) 超过：0分 信贷政策执行 信贷执行情况（70分） 根据信贷政策导向效果评估： 0-70分 央行资金运用情况（30分） 基础20分，根据央行资金运用投向、利率等要求进行增加：0-30分 （三）MPA有关说明 C*是宏观审慎资本充足率，是评估体系的核心，资本扩张受资本约束的要求必须坚持，是对原有合意贷款管理模式的继承，其计算方法如下： &emsp;&emsp;(1) 宏观审慎资本充足率C* = 结构性参数 * （最低资本充足率要求 + 系统重要性附加资本 + 储备资本 + 资本缓冲要求）； &emsp;&emsp;(2) 结构性参数αi主要参考机构稳健状况和信贷政策执行情况，由人民银行确定； &emsp;&emsp;(3) 最低资本充足率、储备资本参照相关监管要求； &emsp;&emsp;(4) 系统重要性附加资本 = 0.5% + (1% - 0.5%) * i行本外币资产规模 / 基准行本外币资产规模； &emsp;&emsp;(5) 资本缓冲要求 = 留存资本缓冲 + 逆周期资本缓冲； &emsp;&emsp;(6) 参数设定将另行通知；金融机构试算时可采用2015年的参数 利率定价行为是重要考察方面，以促进金融机构提高自主定价能力和风险管理水平，约束非理性定价行为，避免恶性竞争，维护良好的市场竞争环境。 广义信贷指标为各项贷款余额、债券投资、股权及其他投资、买入返售资产、存放非存款金融机构款项以及表外理财等合计数。 指标评分如有区间，按区间内均匀分布的方式计算具体分值。各项指标均以金融机构法人为单位，按上一季度数据计算。 区域性系统重要性机构主要从资产规模、替代性、关联度等方面加以确定。 （四）MPA扩容与完善MPA并非了成不变，而是处于不断调整完善的过程。 2017年第一季度，将表外理财正式纳入MPA广义信贷指标范围。 2017年三季度货币政策执行报告明确探索将绿色信贷纳入MPA评估体系中。 2018年第一季度起将同业存单纳入MPA的同业负债占比指标。 央行行长易纲在《中国金融》2018年第3期“货币政策回顾与展望”文章中，表示正探索将影子银行、房地产金融、互联网金融等纳入宏观审慎政策框架，将同业存单、绿色信贷业绩考核纳入MPA考核，优化跨境资本流动宏观审慎政策，对资本流动进行逆周期调节。其中，绿色金融纳入MPA信贷政策执行情况考核首先对24家系统重要性金融机构实施。 进一步完善全口径跨境融资宏观审慎政策，提高跨境融资便利性，防范跨境资金流动。 2018年7月25日，部分银行接央行通知，从2018年二季度起，下调MPA考核中宏观审慎资本充足率的结构性参数和信贷顺周期贡献度参数，适度放宽对银行考核要求。 2019年一季度将制造业中长期贷款和信用贷款纳入MPA考核。 2019年二季度在MPA考核中调整了小微和民营企业贷款指标。 2019年三季度将LPR应用情况纳入MPA考核。 （五）银行业压力测试&emsp;&emsp;2018年上半年，央行选取了20家总资产规模在5000亿元以上的银行进行了压力测试，这20家银行分别为交通银行、邮储银行、兴业银行、浦发银行、民生银行、广发银行、恒丰银行、渤海银行、江苏银行、南京银行、宁波银行、盛京银行、天津银行、徽商银行、杭州银行、成都农商行、重庆农商行、北京农商行、上海农商行和广州农商行。 1. 偿付能力宏观情景压力测试（覆盖信用风险和市场风险）(1) 主要考察宏观经济下行对银行盈利能力和资本充足水平的影响，设置轻度和重度两个压力情景。 (2) 宏观情景指标包含GDP同比增速、CPI涨幅、政策性利率、短期及长期市场利率和人民币对美元汇率等。 (3) 冲击后核心一级资本充足率、一级资本充足率和资本充足率任何一项分别不低于7.50%、8.50%和10.50%的监管要求。 2. 偿付能力敏感性压力测试(1) 主要考察特定风险冲击对银行整体资本充足水平的瞬时影响。 (2) 以整体信贷资产和重点领域的不良贷款率、损失率、收益率曲线变动等作为压力指标。 (3) 冲击后的资本充足率不低于10.50%。 3. 流动性风险压力测试(1) 考察流动性状况恶化对银行现金流缺口的影响。 (2) 设置轻度和重度压力情况，针对不同表内资产、负债及或有融资义务分别设定不同的流入率或流失率，计算不同期限下的净现金流缺口。 (3) 冲击后全部可动用的合格优质流动性资产可弥补现金流缺口。 风险敞口 压力情景 偿付能力宏观情景压力测试 信用风险 贷款 (1) 轻度冲击为GDP同比增速下降至5.70%； (2) 重度冲击为GDP同比增速下降至4.16%； 应收款项类投资 市场风险 银行账户利率风险 (1) 轻度冲击为付息负债利率上升38个基点，贷款利率上升22.80个基点，其他生息资产利率上升113个基点。 (2) 重度冲击为付息负债利率上升151个基点，贷款利率上升90.60个基点，其他生息资产利率上升186个基点。 债券市场专项市场风险 (1) 轻度冲击为短期利率上升38个基点，长期利率上升113个基点。 (2) 重度冲击为短期利率上升151个基点，长期利率上升186个基点。 汇率风险 (1) 轻度冲击为人民币兑美元汇率下降3.70%； (2) 重度冲击为人民币兑美元汇率下降1.63%。 偿付能力敏感性压力测试 贷款 (1) 轻度冲击为不良贷款率上升100%； (2) 中度冲击为不良贷款率上升300%； (3) 重度冲击为不良贷款率上升700% 房地产贷款风险 (1) 轻度冲击为房地产开发贷款和购房贷款不良率均增加5个百分点 (2) 中度冲击为房地产开发贷款和购房贷款不良率分别增加10个和7个百分点 (3) 中度冲击为房地产开发贷款和购房贷款不良率分别增加15个和10个百分点 “两高一剩”行业贷款风险 (1) 轻度冲击为不良贷款率增加10个百分点； (2) 中度冲击为不良贷款率增加16个百分点； (3) 重度冲击为不良贷款率增加20个百分点。 地方政府债务风险 (1) 轻度冲击为不良贷款率增加5个百分点； (2) 中度冲击为不良贷款率增加10个百分点； (3) 重度冲击为不良贷款率增加15个百分点。 表外业务信用风险 (1) 轻度冲击为发生垫资的表外业务敞口余额占比5%； (2) 中度冲击为发生垫资的表外业务敞口余额占比10%； (3) 重度冲击为发生垫资的表外业务敞口余额占比15%。 投资损失风险 (1) 轻度冲击为非政策性金融债券收益率曲线上移400个基点； (2) 中度冲击为非金融企业债券收益率曲线上移400个基点； (3) 重度冲击为非债券类投资账面余额损失5% 流动性风险压力测试 表内资产负债及或有融资业务 设置轻度、重度两种压力场景 对不同到期期限的表内资产负债项目及或有融资业务分别设置流入率或流失率 九、商业银行信贷投向维度（一）普惠金融（贷款）&emsp;&emsp;所谓普惠金融，是指全方位有效地为社会所有阶层和群体提供金融服务，特别是在传统金融理念基础上，被正规金融体系排外的农户、贫困人群及小微企业，能及时有效地获取价格合理、便捷安全的金融服务。因此，简单点就是以前那些银行看不上、顾不到、选择性忽视的客户（如中小微企业、个体工商户、城镇低收入、贫困群体等）现在是普惠金融重点关注的领域了。 &emsp;&emsp;很显然，普惠金融并不是中国的创新，但可以说是中国在引领，目前国家已经把“普惠金融”当成一项国家战略，并制订五年计划来实施，相信此次针对普惠金融的定向降准将会作为一个中长期政策一直被使用。 &emsp;&emsp;具体来看，普惠金融领域贷款包括：单户授信小于1000万元的小型企业贷款、单户授信小于1000万元的微型企业贷款、个体工商户经营性贷款、小微企业主经营性贷款、农户生产经营贷款、创业担保（下岗失业人员）贷款、建档立卡贫困人口消费贷款和助学贷款。上述贷款数据采用人民银行调查统计部门统一口径的统计数据。 （二）小微企业“两增两控”&emsp;&emsp;“两增”即单户授信总额1000万元以下（含）小微企业贷款增速不低于各项贷款同比增速，贷款户数不低于上年同期水平。“两控”即合理控制小微企业贷款质量水平和贷款综合成本。 &emsp;&emsp;2018年3月19日，银监会发布《关于2018年推动银行业小微企业金融服务高质量发展的通知》（银监办发[2018]29号）。该《通知》在继续监测“三个不低于”、确保小微企业信贷总量稳步扩大的基础上，重点针对单户授信1000万元以下（含）的小微企业贷款，提出“两增两控”的新目标。 （三）民营企业“一二五”目标&emsp;&emsp;“一二五”目标，即小微企业贷款增速不低于各项贷款平均增速，小微企业贷款户数不低于上年同期户数，小微企业申贷获得率不低于上年同期水平。 &emsp;&emsp;2018年11月7日，银保监会主席郭树清接受采访时表示“据不完全统计，现在银行业贷款余额中，民营企业贷款占25%，而民营经济在国民经济中的份额超过60%。民营企业从银行得到的贷款和它在经济中的比重还不相匹配、不相适应”。后续考虑对民营企业的贷款要实现“一二五”的目标，即在新增的公司类贷款中，大型银行对民营企业的贷款不低于1/3，中小型银行不低于2/3，争取三年以后，银行业对民营企业的贷款占新增公司类贷款的比例不低于50%。 十、大资管行业维度（一）基本规范1. 合格投资者&emsp;&emsp;资管新规之后，将合格投资者的认定标准归于统一，从认定原则上延用了2014年8月颁布的《私募投资基金监督管理暂行办法》，即采用资产规模或收入水平和单只资管产品的最低认购金额的双重标准进行认定。 定义 资产规模或收入水平标准 最低认购金额标准 资管新规 具备相应风险识别能力和风险承担能力，投资于单只资产管理产品不低于一定金额且符合下列条件的自然人和法人或者其他组织。 (1) 具有2年以上投资经历，且满足以下条件之一：家庭金融净资产不低于300万元，家庭金融资产不低于500万元，或者近3年本人年均收入不低于40万元。 (2) 最近一年末净资产不低于1000万元的法人单位。 (2) 金融管理部门视为合格投资者的其他情形。 合格投资者投资于单只固定收益类产品的金额不低于30万元，投资于单只混合类产品的金额不低于40万元，投资于单只权益类产品、单只产品及金融衍生品类产品的金额不低于100万元。 投资者不得使用贷款、发行债券等筹集的非自有资金投资资产管理产品。 资产管理计划接受其他资产管理产品参与的，不合并计算其他资产管理产品的投资者人数。 资产管理计划接受其他私募资产管理产品参与的，证券期货经营机构应当有效识别资产管理计划的实际投资者与最终资金来源。 商业银行理财业务 (1) 具有2年以上投资经历，且满足以下条件之一的自然人：家庭金融净资产不低于300万元，家庭金融资产不低于500万元，或者近3年本人年均收入不低于40万元人民币； (2) 最近一年末净资产不低于1000万元人民币的法人或者依法成立的其他组织； (3) 国务院银行业监督管理机构规定的其他情形。 证券期货私募经营机构私募资产管理业务 (1) 具有2年以上投资经历，且满足以下条件之一的自然人：家庭金融净资产不低于300万元，家庭金融资产不低于500万元，或者近3年本人年均收入不低于40万元人民币； (2) 最近一年末净资产不低于1000万元人民币的法人或者依法成立的其他组织； (3) 依法设立并接受国务院银行业监督管理机构，包括证券公司及其子公司、基金管理公司及其子公司、期货公司及其子公司、在基金业协会登记的私募基金管理人、商业银行、金融资产投资公司、信托公司、保险公司、保险资产管理公司、财务公司及中国证监会认定的其他机构； (4) 接受国务院金融监督管理机构监管的机构发行的资产管理产品； (5) 基本养老金、社会保障基金、企业年金等养老基金，慈善基金等社会公益基金，合格境外机构投资者（QFII）、人民币合格境外机构投资者（RQFII）； (6) 中国证监会视为合格投资者的其他情形。 集合资金信托 (1) 最低金额不低于100万元人民币。单笔委托金额300万元人民币以上的投资者数量不受限制； (2) 个人或家庭金融资产总计超过100万元人民币，且能提供相关财产证明的自然人； (3) 个人收入在最近3年内每年收入超过20万元人民币或夫妻双方合计收入在最近3年内每年超过30万元人民币且能提供相关收入证明的自然人。 资产支持证券 按照《私募投资基金监督管理暂行办法》来认定。资产支持证券应当面对合格投资者发行，发行对象不得超过200人，单笔认购不少于100万元人民币发行面值或等值份额。 私募投资基金 具备相应风险识别能力和风险承担能力，投资于单只私募基金的金额不低于100万元且符合下列相关标准的单位和个人： (1) 净资产不低于1000万元人民币的单位； (2) 金融资产不低于300万元人民币或者最近三年年均收入不低于50万元的个人； (3) 社会保障基金、企业年金等养老基金，慈善基金等社会公益基金； (4) 依法设立并在基金业协会备案的投资计划； (5) 投资于所管理私募基金的私募基金管理人及其从业人员； (6) 中国证监会规定的其他投资者； (7) 以合伙企业、契约等非法人形式，通过汇集多数投资者的资金直接或者间接投资于私募基金的，私募基金管理人或者私募基金销售机构应当穿透核查最终投资者是否为合格投资者，并合并计算投资者人数。 商业银行理财业务 普通理财客户 根据风险承受能力评估的级别来划分 (1) 风险评级为一级和二级的理财产品，单一客户销售起点金额不得低于5万元人民币； (2) 风险评级为三级和四级的理财产品，单一客户销售起点金额不得低于10万元人民币； (3) 风险评级为五级的理财产品，单一客户销售起点金额不得低于20万元人民币； 私人银行客户 金融资产达到600万元人民币及以上的商业银行客户，商业银行在提供服务时，有客户提供相关证明并签字确认。需进行风险承受能力评估。 高资产净值客户 (1) 单笔认购理财产品不少于100万元人民币的自然人，需要进行风险承受能力评估； (2) 认购理财产品时，个人或家庭金融净资产总计超过100万元人民币，且能提供相关证明的自然人； (3) 个人收入在3年内每年超过20万元人民币或者家庭合计收入在3年内每年超过30万元人民币，且能提供相关证明的自然人。 2. 风险准备金(1) 资管新规明确金融机构应当按照资产管理产品管理费收入的10%计提风险准备金，或按规定计提操作风险资本或相应风险资本准备，风险准备金余额达到产品余额的1%时可以不再提取。 (2) 信托公司每年应当从税后利润中提取5%作为信托赔偿准备金，但该赔偿准备金累计总额达到公司注册资本的20%时，可不再提取。同时，信托公司也会计提相应的风险资本。 (3) 证券公司需要按照资管业务净收入的15%计提操作风险准备，同时还需要计提特定风险资本： &emsp;&emsp;第一，结构化集合资管计划计提1%的风险准备； &emsp;&emsp;第二，投资非标资产的定向资管计划计提 0.90%的风险准备； &emsp;&emsp;第三，各类私募投资基金计提0.70%的风险准备； &emsp;&emsp;第四，其他定向资管计划计提0.50%的风险准备； &emsp;&emsp;第五，参与股票质押式回购业务的资管计划加计1.50%的风险准备。 (4) 基金子公司应当按管理费收入的10%计提风险准备金，达到专户子公司所管理资产规模净值的1%时可不再计提，同时也需要计提风险资本。 (5) 公募基金应当每月从基金管理费收入的10%计提风险准备金，余额达到上季末管理基金资产净值的1%时可不再提取。 3. 资管产品估值&emsp;&emsp;2019年8月5日、8月16日，中国银行业协会、证监会和中基协相继发布资管产品估值指引的征求意见稿，意味着资管产品估值统一规范的局面正在形成。 &emsp;&emsp;由于中基协在估值方面具有丰富的经验，因此中银协发布的估值指引基本充分借鉴了中基协的模式，在绝大多数投资品种（以标准化为主）估值方法上基本保持一致。 (1) 对于权益类证券和固定收益类证券主要以公允价值为主，这里的估值方法要么参照估值日收盘价、最近交易日收盘价、估值技术或直接使用第三方估值结果（如中债登和中证登），其中基金主要采取份额净值或日基金收益等标准。 (2) 对于长期停牌股票，均明确了指数收益法、可比公司法、市场价格模型法、现金流折现法、市场乘数法等估值方法。 (3) 对于限售股票，均引入了流动性折扣，或引入看跌期权法。 (4) 对非上市股权，中基协和中银协的估值方法也比较一致，均采用市场法（参考最近融资价格法、市场乘数法、行业指标法）；收益法（现金流折现法和股利折现法）；成本法（净资产法）等常用的估值方法。 投资品种 中国基金业协会 中国银行业协会 标准化投资品种 权益类证券（公允价值、交易类金融资产） 上市流通股 估值日收盘价（最近交易日收盘价或重大事件调整等）。 优先股 估值日收盘价（最近交易日收盘价或重大事件调整等）、现金流折现模型等。 长期停牌股票 采用指数收益法、可比公司法、市场价格模型法、现金流折现法、市场乘数法、重置成本法等估值技术（中基协还包括CAPM）。 限售股票 引入流动性折扣（依据第三方估值机构或看跌期权法等方法）。 估值期货 估值日或最近交易日结算价。 黄金ETF 收盘价或最近结算价。 固定收益类（交易性、以摊余成本法计量的金融资产） 交易所固收证券 选取中证登提供的估值净价。 交易所含转股权固收证券 使用净价进行估值。 ABS和私募债 按成本估值（持续评估）。 银行间固收证券 选取中债登提供的价格数据。 跨市场品种 分开进行估值（根据第三方）。 其它摊余成本法 按企业会计准则。 配股权（交易性金融资产） 公允价值计量（或估值技术）。 存款（含同业，摊余成本计量） 成本法。 证券投资基金（交易性金融资产） 非上市基金 非货基（估值日的净值）、货基（前一估值日后至估值日期间的万份收益计提估值日基金收益）。 上市基金 ETF、定开与封闭式（收盘价）；LOF（份额净值）。 衍生品（交易性金融资产） 结算价等。 公允价值计量（或估值技术）。 结构性理财 仅银行业协会:采用蒙特卡洛模拟的方法对风险因子进行模拟，在模拟出标的资产未来价值后，根据合同中收益的分配规则确定在不同情况下可获得的收益。重复以上步骤来获得大量的随机路径并计算出每条路径可能收入现金流的折现值，这些现金流折现值的平均值即为该产品在估值日的公允价值 非标债权资产 三种情形可使用摊余成本法： (1) 资产管理产品为封闭式产品，且所投金融资产以收取合同现金流为目的并持有到期。 (2) 资产管理产品为封闭式产品，且所投金融资产暂不具备活跃交易市场，或者在活跃交易市场中没有报价、也无法采用适当的估值技术可靠计量公允价值。 (3) 金融机构前期以摊余成本法计量的金融资产的加权平均价格与资产管理产品实际兑付时金融资产的价值的偏离度达到5%或以上的产品数超过所发行产品总数的5%，不得再发行以摊余成本计量金融资产的资产管理产品。 非上市公司股权（新三板挂牌企业参照执行） 三种情形可使用摊余成本法： 估值日估计各单项投资的公允价值，采取以下的几种方法： 市场法（参考最近融资价格法、市场乘数法、行业指标法）；收益法（现金流折现法和股利折现法）；成本法（净资产法）。 金融资产减值问题（针对非交易性的金融资产，包括房产、交易量较低的债券、股票、文物、担保债务凭证、私募股权） (1) 在理财产品报告日和产品开放日前应对该类资产进行减值计量，并按照不同情形分别计量其损失准备、确认预期信用损失及其变动。 (2) 理财产品管理人无法对金融资产进行合理评估预期风险计提减值时，可采用“侧袋估值”。 4. 侧袋机制&emsp;&emsp;中银协的估值指引中明确了侧袋估值的使用，其主要是针对无法计提减值时的情形。随后，证监会和中基协针对侧袋机制出台了征求意见稿，这里有必要对这一新概念进行讨论： &emsp;&emsp;侧袋机制，指的是将难以合理估值的资产从基金组合资产账户中独立出来、形成侧袋账户进行独立管理，其他基金组合资产存放在主袋账户的机制。 &emsp;&emsp;侧袋机制将资管投资品种进行分类，一部分放到主袋，一部分放到侧袋。其中，侧袋中的投资品种通常具有流动性差（如限售证券或停牌证券等）、变现能力弱（如违约证券等等）等特点。因此，侧依机制的建议是为了将风险进行隔离，有助于投资者赎回，避免受限资产被强制变相折价甩卖，并可以减轻对市场的冲击。从这个角度看，侧袋机制本质上是一种流动性风险管理工具，即进行风险隔离。 &emsp;&emsp;证监会体系目前明确封闭式基金、货基、交易型开放式ETF、上市型开放式基金（LOF）不采用侧袋机制。并且一般放入侧袋账户的资产主要为流动性较差的品种，如房产、交易量较低的债券、股票、文物、担保债务凭证、私募股权、违约债券、停牌或受限股票等等。 5. 资管行业的6种流动性风险管理工具&emsp;&emsp;证监会2017年8月31日发布的《公开募集开放式证券投资基金流动性风险管理规定》明确了基金的六大风险管理工具，对于整个资管行业具有普适性，这6种流动性风险管理工具分别为（1）延期办理巨额赎回申请；（2）暂停接受赎回申请；（3）延续支付赎回款项；（4）收取短期赎回费；（5）暂停基金估值；（6）摆动定价等。 &emsp;&emsp;此外，如果加上前面的侧袋机制，则意味着资管行业的流动性风险管理工具有七种。 （二）证券公司&emsp;&emsp;资料来源2016年6月证监会发布的《关于修改&lt;证券公司风险控制指标管理办法&gt;的决定》修正。证券公司的风险控制指标体系主要以净资本和流动性为核心。 1. 净资本 = 核心净资本 + 附属净资本(1) 核心净资本=净资产-资产项目的风险调整-或有负债的风险调整+其他调整项目。 (2) 附属净资本=长期次级债*规定比例+其他调整项目。 (3) 证券公司计算核心净资本时，应当按照规定对有关项目充分计提资产减值准备。 (4) 证券公司对控制证券业务子公司出具承诺书提供担保承诺的，应当按照担保承诺金额的一定比例扣减核心净资本。从事证券承销与保荐、证券资产管理业务等中国证监会认可的子公司可以将母公司提供的担保承诺按一定比例计入核心资本。 (5) 证券公司向股东或机构投资者借入或发行的次级债，可按照一定比例计入附属净资本或扣减风险资本准备。 (6) 证券公司经营证券经纪业务的净资本不得低于2000万元，经营证券承销与保荐、证券自营、证券资产管理、其他证券业务等业务之一的，其净资本不得低于5000万元。 (7) 证券公司经营证券经纪业务，同时经营证券承销与保荐、证券自营、证券资产管理、其他证券业务等业务之一的，其净资本不得低于1亿元。 (8) 证券公司经营证券承销与保荐、证券自营、证券资产管理、其他证券业务中两项及两项以上的，净资本不得低于2亿元。 2. 风险控制指标(1) 风险覆盖率 = 净资本/各项风险资本准备之和，不得低于100%； (2) 资本杠杆率 = 核心净资本/表内外资产总额，不得低于8%； (3) 流动性覆盖率 = 优质流动性资产/未来30天现金净流出量，不得低于100%； (4) 净稳定资金比率 = 可用稳定资金/所需稳定资金，不得低于100%。 (5) 净资本/净资产不得低于40%； (6) 净资本/负债不得低于8%； (7) 自营权益类证券及证券衍生品/净资本不得高于100%，其中利率互换投资规模以利率互换合约名义本金总额的5%计算； (8) 自营固定收益类证券/净资本不得高于500%； (9) 持有一种权益类证券的成本与净资本的比例不得高于30%； (10) 持有一种权益类证券的市值与其总市值的比例不得高于5%，但因包销导致的情形和中国证监会另有规定的除外； (11) 证券公司对客户融资融券最长期限不得高于6个月； (12) 对单一客户的融资或融券规模与净资本的比例不得高于5%； (13) 接受单只担保股票市值与该股票总市值比例前五名。 &emsp;&emsp;需要指出得是，这里的“证券衍生品”具体包括权证、股指期货；“权益类证券”具体包括股票、股票基金、混合基金、集合理财产品、信托产品；“固定收益类证券”具体包括债券、债券基金、央行票据、货币市场基金、资产支持证券。 （三）基金子公司&emsp;&emsp;本部分资料来源2016年11月证监会发布的《基金管理公司特定客户资产管理子公司风险控制指标管理暂行规定》（证监会2016年第30号公告）。 1. 风险控制指标(1) 净资本不得低于1亿元； (2) 净资本/各项风险资本准备之和，不得低于100%； (3) 净资本/净资产不得低于40%； (4) 净资产/负债不得低于20%。 2. 风险准备金 = 管理费收入的10%（四）公募基金1. 发行端(1) 单一投资者持有份额超过50%的，应当采用封闭式或定期开放运作模式（定期开放周期不得低于3个月、货币市场基金除外），且采用发起式基金形式。 (2) 对除货币市场基金与交易型开放式指数基金以外的开放式基金，对持续持有期少于7日的投资者收取不低于1.5%的赎回费，并将上述赎回费全额计入基金财产。 2. 投资端(1) 同一基金管理人管理的全部基金持有一家公司发行的证券，不得超过该证券的10%。 (2) 同一基金管理人管理的全部开放式基金持有一家上市公司的可流通股票市值，不得超过该股市可流通市值的15%。 (3) 同一基金管理人管理的全部投资组合持有一家上市公司的可流通股票市值，不得超过该上市公司可流通市值的30%。 &emsp;&emsp;其中，完全按照有关指数的构成比例进行证券投资的开放式基金以及中国证监会认定的特殊投资组合可不受前述比例限制。 (4) 同一基金管理人管理的全部证券投资基金投资于同一原始权益人的各类资产支持证券，不得超过其各类资产支持证券合计规模的10%。单只证券投资基金持有的同一信用级别资产支持证券的比例，不得超过该资产支持证券规模的10%。 (5) 单只证券投资基金持有的全部资产支持证券，其市值不得超过该基金资产净值的20%，中国证监会规定的特殊品种除外。 (6) 单只开放式基金主动投资于流动性受限资产的市值合计不得超过该基金资产净值的15%。 &emsp;&emsp;因证券市场波动、上市公司股票停牌、基金规模变动等基金管理人之外的因素致使基金不符合前款所规定比例限制的，基金管理人不得主动新增流动性受限资产的投资。 (7) 单只基金持有一家公司发行的证券，其市值不得超过基金资产净值10%（其中可转债基金投资于可转债部分则可以豁免）。 (8) 单只开放式基金主动投资于流动性受限资产的市值合计不得超过该基金资产净值的15%。 (9) 单只基金持有其他基金（不含货币市场基金），其市值不得超过基金资产净值10%，但基金中基金除外。 (10) 开放式基金应当保持不低于基金资产净值5%的现金或者到期日在一年以内的政府债券，以备支付基金份额持有人的赎回款项，但中国证监会规定的特殊基金品种除外。 (11) 单只公募资产管理产品投资单只证券或者单只证券投资基金的市值不得超过该资产管理产品净资产的10%。 (12) 基金不得投资有锁定期、但锁定期不明确的证券，封闭式基金投资流通受限证券的锁定期，不得超过封闭式基金的剩余存续期。 3. 杠杆比例要求(1) 基金总资产/基金净资产，不得高于140%。 (2) 封闭式基金和保本基金的总资产/净资产不得高于200%。 (3) 杠杆型基金的杠杆率由基金合同自行约定 ，但基金名称中应有“杠杆”二字。 (4) 基金财产参与股票发行申购，单只基金所申报的金额，不得超过该基金的总资产。 (5) 进入全国银行间同业市场的基金管理公司进行债券回购的资金余额不得超过基金净资产的40%。 4. 投资股指期货的交易限制(1) 基金在任何交易日日终，持有的买入股指期货合约价值，不得超过基金资产净值的10%； (2) 开放式基金在任何交易日日终，持有的买入期货合约价值与有价证券市值之和，不得超过基金资产净值的95%；封闭式基金、开放式指数基金（不含增强型）、交易型开放式指数基金（ETF）在任何交易日日终，持有的买入期货合约价值与有价证券市值之和，不得超过基金资产净值的100%； (3) 基金在任何交易日日终，持有的卖出期货合约价值不得超过基金持有的股票总市值的20%； &emsp;&emsp;基金管理公司应当按照中国金融期货交易所要求的内容、格式与时限向交易所报告所交易和持有的卖出期货合约情况、交易目的及对应的证券资产情况等； (4) 基金所持有的股票市值和买入、卖出股指期货合约价值，合计（轧差计算）应当符合基金合同关于股票投资比例的有关约定； (5) 基金在任何交易日内交易（不包括平仓）的股指期货合约的成交金额，不得超过上一交易日基金资产净值的20%； (6) 开放式基金（不含ETF）每个交易日日终，在扣除股指期货合约需缴纳的交易保证金后，应当保持不低于基金资产净值5%的现金，或到期日在一年以内的政府债券； (7) 封闭式基金、ETF每个交易日日终，在扣除股指期货合约需缴纳的交易保证金后，应当保持不低于交易保证金一倍的现金； (8) 保本基金参与股指期货交易不受上述限制，但应当符合基金合同约定的保本策略和投资目标，且每日所持期货合约及有价证券的最大可能损失，不得超过基金净资产扣除用于保本部分资产后的余额。 &emsp;&emsp;担保机构应当充分了解保本基金的股指期货交易策略和可能损失，并在担保协议中作出专门说明。 5. 投资国债期货的交易限制(1) 基金在任何交易日日终，持有的买入国债期货合约价值，不得超过基金资产净值的15%； (2) 开放式基金在任何交易日日终，持有的买入国债期货和股指期货合约价值与有价证券市值之和，不得超过基金资产净值的95%； &emsp;&emsp;封闭式基金、开放式指数基金（不含增强型）、交易型开放式指数基金（ETF）在任何交易日日终，持有的买入国债期货和股指期货合约价值与有价证券市值之和，不得超过基金资产净值的100%。 &emsp;&emsp;其中，有价证券指股票、债券（不含到期日在一年以内的政府债券）、权证、资产支持证券、买入返售金融资产（不含质押式回购）等。 &emsp;&emsp;债券基金参与国债期货交易不受本项限制，但应当符合基金合同约定的投资策略和投资目标； (3) 基金在任何交易日日终，持有的卖出国债期货合约价值不得超过基金持有的债券总市值的30%； &emsp;&emsp;基金管理人应当按照中国金融期货交易所要求的内容、格式与时限向交易所报告所交易和持有的卖出期货合约情况、交易目的及对应的证券资产情况等； (4) 基金所持有的债券（不含到期日在一年以内的政府债券）市值和买入、卖出国债期货合约价值，合计（轧差计算）应当符合基金合同关于债券投资比例的有关约定； (5) 基金在任何交易日内交易（不包括平仓）的国债期货合约的成交金额不得超过上一交易日基金资产净值的30%； (6) 开放式基金（不含ETF）每个交易日日终，在扣除国债期货和股指期货合约需缴纳的交易保证金后，应当保持不低于基金资产净值5%的现金，或到期日在一年以内的政府债券； (7) 封闭式基金、ETF每个交易日日终，在扣除国债期货和股指期货合约需缴纳的交易保证金后，应当保持不低于交易保证金一倍的现金； (8) 保本基金参与国债期货交易不受上述的限制，但应当符合基金合同约定的保本策略和投资目标，且每日所持期货合约及有价证券的最大可能损失，不得超过基金净资产扣除用于保本部分资产后的余额。 6. 投资商品期货的交易限制(1) 持有所有商品期货合约的价值合计(买入、卖出轧差计算)不低于基金资产净值的90%、不高于基金资产净值的110%。 (2) 持有卖出商品期货合约应当用于风险管理或提高资产配置效率。 (3) 除支付商品期货合约保证金以外的基金财产，应当投资于货币市场工具以及中国证监会允许基金投资的其他金融工具，其中投资于货币市场工具应当不少于80%。 (4) 不得办理实物商品的出入库业务。 (5) 商品期货ETF联接基金财产中，目标商品期货ETF的比例不得低于基金资产净值的90%。 7. FOF（基金中基金）(1) 基金中基金持有单只基金的市值，不得高于基金中基金资产净值的20%，且不得持有其他基金中基金。 其中，ETF联接基金持有目标ETF的市值，不得低于该联接基金资产净值的90%。 (2) 除ETF联接基金外，同一管理人管理的全部基金中基金持有单只基金不得超过被投资基金净资产的20％，被投资基金净资产规模以最近定期报告披露的规模为准。 (3) 基金中基金不得持有具有复杂、衍生品性质的基金份额，包括分级基金和中国证监会认定的其他基金份额，中国证监会认可或批准的特殊基金中基金除外。 (4) 除ETF联接基金外，基金中基金投资其他基金时，被投资基金的运作期限应当不少于1年，最近定期报告披露的基金净资产应当不低于1亿元。 8. 避险策略基金（即原“保本基金”）(1) 避险策略基金单位累计净值低于避险策略周期到期日基金合同约定的投资本金超过2%，或者连续20个交易日（建仓期除外）低于避险策略周期到期日基金合同约定的投资本金的，应当及时予以应对，审慎作出后续安排，并自发生之日起3日内向中国证监会及相关派出机构报告。 (2) 避险策略基金的投资策略应当符合以下审慎监管要求： &emsp;&emsp;第一，避险策略基金投资于稳健资产不得低于基金资产净值的80%。 &emsp;&emsp;其中，稳健资产应为现金，剩余期限不超过剩余避险策略周期1 年的银行存款、同业存单、债券回购、国债、地方政府债券、政策性金融债、中央银行票据、信用等级在AAA（含）以上的债券、信用等级在AAA（含）以上的非金融企业债务融资工具以及中国证监会认可的其他金融工具； &emsp;&emsp;第二，稳健资产投资组合的平均剩余期限不得超过剩余避险策略周期； &emsp;&emsp;第三，避险策略基金投资于具有基金托管人资格的同一商业银行的银行存款、同业存单占基金资产净值的比例合计不得超过20%，投资于不具有基金托管人资格的同一商业银行的银行存款、同业存单占基金资产净值的比例合计不得超过5%； &emsp;&emsp;第四，稳健资产以外的资产为风险资产，基金管理人应当建立客观研究方法，审慎建立风险资产投资对象备选库，并采取适度分散的投资策略，且应当审慎确定风险资产的投资比例。 &emsp;&emsp;其中，风险资产中，投资于权益类资产的，投资金额不得超过安全垫3倍；投资于可转换债券、可交换债券以及信用等级在AA+以下的固定收益类资产的，投资金额不得超过安全垫5倍；投资于信用等级AA+（含）以上的固定收益类资产的，投资金额不得超过安全垫10 倍；各类风险资产的投资金额除以各自倍数上限，加上买入上市期权支付的权利金，合计金额不得超过安全垫。 &emsp;&emsp;这里的安全垫相当于保护层，即基金资产净值与到期日投资本金折现后的差额。 （五）货币市场基金&emsp;&emsp;该信息来源于2016年2月1日施行的《货币市场基金监督管理办法》和2017年10月1日施行的《公开募集开放式证券投资基金流动性风险管理规定》，该规定主要针对摊余成本法的货币市场基金。 1. 禁投项目&emsp;&emsp;货币市场基金不得投资于股票、可转换债券、可交换债券、以定期存款利率为基准利率的浮动利率债券、信用等级在AA+以下的债券与非金融企业债务融资工具。 2. 流动性资产不应低于一定比例(1) 现金、国债、中央银行票据、政策性金融债券占基金资产净值的比例合计不得低于 5%; (2) 现金、国债、中央银行票据、政策性金融债券以及五个交易日内到期的其他金融工具占基金资产净值的比例合计不得低于 10%; (3) 到期日在 10 个交易日以上的逆回购、银行定期存款等流动性受限资产投资占基金资产净值的比例合计不得超过 30%; (4) 除发生巨额赎回、连续3个交易日累计赎回 20%以上或者连续 5 个交易日累计赎回 30%以上的情形外，债券正回购的资金余额占基金资产净值的比例不得超过 20%。 3. 投资交易限制(1) 同一机构发行的债券、非金融企业债务融资工具及其作为原始权益人的资产支持证券占基金资产净值的比例合计不得超过 10%，国债、中央银行票据、政策性金融债券除外。 (2) 货币市场基金投资于有固定期限银行存款的比例，不得超过基金资产净值的 30%，但投资于有存款期限，根据协议可提前支取的银行存款不受上述比例限制。 (3) 货币市场基金投资于具有基金托管人资格的同一商业银行的银行存款、同业存单占基金资产净值的比例合计不得超过 20%，投资于不具有基金托管人资格的同一商业银行的银行存款、同业存单占基金资产净值的比例合计不得超过 5%。 (4) 要求采用摊余成本法核算的货币市场基金要实施规模控制，同一基金管理人用摊余成本法核算的货币市场基金的月末资产净值合计不得超过风险准备金余额的200倍。同时，货币市场基金正回购余额占基金资产净值的比例不得高于20%。 (5) 货币市场基金投资于主体信用评级低于AAA的机构发行的金融工具占基金资产净值的比例合计不得超过10%，其中单一机构发行的金融工具占基金资产净值的比例合计不得超过 2%。 (6) 同一基金管理人管理的全部货币市场基金投资同一商业银行的银行存款及其发行的同业存单与债券，不得超过该商业银行最近一个季度末净资产的 10%。 (7) 货币市场基金投资组合的平均剩余期限不得超过 120 天，平均剩余存续期不得超过 240 天。 (8) 货币市场基金的投资久期有严格的要求： 前10名份额持有人合计持有份额 投资组合平均剩余期限 平均剩余存续期 投资组合中现金、国债、央票、政策性金融债券以及5个交易日内到期的其他金融工具占比 超过50% 不得超过60天 不得超过120天 不得低于30% 超过20% 不得超过90天 不得超过180天 不得低于20% （六）信托公司1. 一般规定(1) 信托公司注册资本最低限额为3亿元人民币或等值的可自由兑换货币，注册资本为实缴货币资本。 (2) 一般信托的投资起点为100万，但单笔委托金额在300万元以上的自然人投资者和合格的机构投资者数量则不受限制，其中我们常常听到的信托受益权为等额份额的信托单位。 (3) 信托公司向他人提供贷款不得超过其管理的所有信托计划实收余额的30%，不得将同一公司管理的不同信托计划投资于同一项目。 (4) 单个信托计划的自然人人数不得超过50人，信托期限不少于1年。 (5) 信托公司不得开展除同业拆入业务以外的其他负债业务，且同业拆入余额不得超过其净资产的20%、对外担保余额不得超过其净资产的50%。 2. 净资本管理净资本 = 净资产-各类资产的风险扣除项-或有负债的风险扣除项-中国银行业监督管理委员会认定的其他风险扣除项。 风险资本 = 固有业务风险资本＋信托业务风险资本＋其他业务风险资本。 (1) 信托公司净资本不得低于2亿元。 (2) 净资本/各项风险资本之和不得低于100%。 (3) 净资本/净资产不得低于40%。 （七）商业银行理财业务与商业银行理财子公司&emsp;&emsp;《商业银行理财业务监督管理办法》与《商业银行理财子公司管理办法》分别于2018年9月28日和12月2日正式发布，在延续资管新规的总体指导思想外，整体上看略有放松。 发行端 销售端 投资端 商业银行理财业务 (1) 公募和私募： 合格投资者； (2) 固收类、权益类、衍生类和混合类； (3) 封闭式和开放式； (4) 商业银行不得发行分级理财产品 (1) 公募：销售起点为1万元； (2) 私募：固收类30万元、混合类40万元、权益类和商品衍生品类100万元； (3) 销售渠道：银行业金融机构以及专区销售和双录要求； (4) 在私募理财产品销售方面，借鉴国内外通行做法，引入不少于24小时的投资冷静期要求。 (1) 不得直接投资于信贷资产，不得直接或间接投资于本行信贷资产及其受（收）益权，不得直接或间接投资于本行或者其他银行业金融机构发行的理财产品，不得直接或间接投资于本行发行的次级信贷资产支持证券； (2) 面向非机构投资者发行的理财产品不得直接或间接投资于不良资产及受（收）益权、不良资产支持证券，国务院银行业监督管理机构另有规定的除外； (3) 不得直接或间接投资于由未经金融监督管理部门许可设立、不持有金融牌照的机构发行的产品或管理的资产，金融资产投资公司的附属机构依法依规设立的私募股权投资基金以及国务院银行业监督管理机构另有规定的除外； (4) 全部理财产品投资于单一债务人及其关联企业的非标准化债权类资产余额，不得超过本行资本净额的10%； (5) 商业银行全部理财产品投资于非标准化债权类资产的余额在任何时点均不得超过理财产品净资产的35%，也不得超过本行上一年度审计报告披露总资产的4%； (6) 每只公募理财产品持有单只证券或单只公募证券投资基金的市值不得超过该理财产品净资产的10%； (7) 商业银行全部公募理财产品持有单只证券或单只公募证券投资基金的市值，不得超过该证券市值或该公募证券投资基金市值的30%； (8) 商业银行全部理财产品持有单一上市公司发行的股票，不得超过该上市公司可流通股票的30%； (9) 商业银行每只开放式公募理财产品的杠杆水平不得超过140%，每只封闭式公募理财产品、每只私募理财产品的杠杆水平不得超过200%； (10) 不得用自有资金购买本行发行的理财产品，不得为理财产品投资的非标准化债权类资产或权益类资产提供任何直接或间接、显性或隐性的担保或回购等代为承担风险的承诺；不得用本行信贷资金为本行理财产品提供融资和担保。 商业银行理财子公司 (1) 公募理财和私募理财； (2) 可以发行分级式理财产品和发起式理财产品。 (1) 代销机构不局限于银行业金融机构； (2) 不设销售起点 (1) 不得直接投资于信贷资产，不得直接或间接投资于主要股东的信贷资产及其受（收）益权，不得直接或间接投资于主要股东发行的次级信贷资产支持证券，面向非机构投资者发行的理财产品不得直接或间接投资于不良资产及受（收）益权； (2) 不得直接或间接投资于本公司发行的理财产品； (3) 银行理财子公司全部理财产品投资于非标准化债权类资产的余额在任何时点均不得超过理财产品净资产的35%； (4) 同一银行理财子公司全部开放式公募理财产品持有单一上市公司发行的股票，不得超过该上市公司可流通股票的15%； (5) 分级理财产品不得投资其他分级资产管理产品，不得直接或间接对优先级份额投资者提供保本保收益安排； (6) 银行理财子公司以自有资金投资于本公司发行的理财产品，不得超过其自有资金的20%，不得超过单只理财产品净资产的10%，不得投资于分级理财产品的劣后级份额； (7) 公募理财产品可直接投资股票，且对理财产品的同向和反向交易进行管控。","categories":[{"name":"金融业务","slug":"金融业务","permalink":"http://ajayhao.github.io/categories/%E9%87%91%E8%9E%8D%E4%B8%9A%E5%8A%A1/"}],"tags":[{"name":"金融","slug":"金融","permalink":"http://ajayhao.github.io/tags/%E9%87%91%E8%9E%8D/"}]},{"title":"Python3及Django2.6环境搭建","slug":"py3-django-env-setup","date":"2019-10-22T14:07:00.000Z","updated":"2019-10-22T14:07:00.000Z","comments":true,"path":"2019/10/22/py3-django-env-setup/","link":"","permalink":"http://ajayhao.github.io/2019/10/22/py3-django-env-setup/","excerpt":"","text":"Python3及Django2.2环境搭建 安装python，安装后将D:\\Software\\Common\\Anaconda3和D:\\Software\\Common\\Anaconda3\\Scripts目录加到系统环境变量path中。 安装django，下载 Django 压缩包，解压并和Python安装目录放在同一个根目录，进入 Django 目录，执行python setup.py install，然后开始安装，Django将要被安装到Python的Lib下site-packages。 在cmd中执行以下命令，尝试创建新项目。 django-admin startproject helloPy 如果报”pkg_resources.DistributionNotFound: The ‘sqlparse’ distribution was not found and is required by Django”，则说明缺少 sqlparse 模块。安装命令： pip install sqlparse 如果报”mysqlclient 1.3.13 or newer is required;”，则需要升级mysqlclient版本执行以下检查mysqlclient当前版本。 pip show mysqlclient a. 在D:\\Software\\Common\\Anaconda3\\Lib\\site-packages\\Django-2.2.6-py3.6.egg\\django\\db\\backends\\mysql中修改base.py，注释掉以下语句： if version &lt; (1, 3, 13): raise ImproperlyConfigured(&#39;mysqlclient 1.3.13 or newer is required; you have %s.&#39; % Database.__version__) b. D:\\Software\\Common\\Anaconda3\\Lib\\site-packages\\Django-2.2.6-py3.6.egg\\django\\db\\backends\\mysql中修改operations.py，将第146行： query = query.decode(errors=&#39;replace&#39;) 修改为 query = query.encode(errors=&#39;replace&#39;)","categories":[{"name":"技术","slug":"技术","permalink":"http://ajayhao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"python","slug":"python","permalink":"http://ajayhao.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"http://ajayhao.github.io/tags/django/"}]},{"title":"Mybatis-JDBCType与javaType映射关系","slug":"mybatis-jdbcType-javaType","date":"2017-07-13T10:31:00.000Z","updated":"2017-07-13T10:31:00.000Z","comments":true,"path":"2017/07/13/mybatis-jdbcType-javaType/","link":"","permalink":"http://ajayhao.github.io/2017/07/13/mybatis-jdbcType-javaType/","excerpt":"","text":"留备便查 JDBCType JavaType CHAR String VARCHAR String LONGVARCHAR String NUMERIC java.math.BigDecimal DECIMAL java.math.BigDecimal BIT boolean BOOLEAN boolean TINYINT byte SMALLINT short INTEGER int BIGINT long REAL float FLOAT double DOUBLE double BINARY byte[] VARBINARY byte[] LONGVARBINARY byte[] DATE java.sql.Date TIME java.sql.Time TIMESTAMP java.sql.Timestamp DATETIME java.sql.Timestamp CLOB Clob BLOB Blob DATALINK java.net.URL","categories":[{"name":"技术","slug":"技术","permalink":"http://ajayhao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://ajayhao.github.io/tags/Java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://ajayhao.github.io/tags/Mybatis/"}]},{"title":"Java多线程系列(一)-正确使用 Volatile 变量","slug":"multithread-volatile","date":"2016-11-30T09:09:02.000Z","updated":"2016-11-30T09:09:02.000Z","comments":true,"path":"2016/11/30/multithread-volatile/","link":"","permalink":"http://ajayhao.github.io/2016/11/30/multithread-volatile/","excerpt":"摘选并翻译自Oracle Java 语言架构师 Brian Goetz的专栏月刊：Java 理论与实践 Volatile 变量Volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。即线程能够自动发现 volatile 变量的最新值。Volatile 变量可用于提供线程安全，但是只能应用于非常有限的一组用例：多个变量之间或者某个变量的当前值与修改后值之间没有约束。因此，单独使用 volatile 还不足以实现计数器、互斥锁或任何具有与多个变量相关的不变式（Invariants）的类（例如 “start &lt;=end”）。出于简易性和代码的可读性上，使用 volatile 变量比使用锁更好些。此外，volatile 变量不会像锁那样造成线程阻塞，因此也很少造成可伸缩性问题。在某些情况下，如果读操作远远大于写操作，volatile 变量还可以提供优于锁的性能优势。","text":"摘选并翻译自Oracle Java 语言架构师 Brian Goetz的专栏月刊：Java 理论与实践 Volatile 变量Volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。即线程能够自动发现 volatile 变量的最新值。Volatile 变量可用于提供线程安全，但是只能应用于非常有限的一组用例：多个变量之间或者某个变量的当前值与修改后值之间没有约束。因此，单独使用 volatile 还不足以实现计数器、互斥锁或任何具有与多个变量相关的不变式（Invariants）的类（例如 “start &lt;=end”）。出于简易性和代码的可读性上，使用 volatile 变量比使用锁更好些。此外，volatile 变量不会像锁那样造成线程阻塞，因此也很少造成可伸缩性问题。在某些情况下，如果读操作远远大于写操作，volatile 变量还可以提供优于锁的性能优势。 正确使用 volatile 变量的条件能够使用 volatile 变量来替代锁的条件很有限。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件： 对变量的写操作不依赖于当前值。 该变量没有包含在具有其他变量的不变式中。 这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确的操作需要使 x 的值在操作期间保持不变，而 volatile 变量无法实现这点。大多数编程情形都会与这两个条件的其中之一冲突，使得 volatile 变量不能像 synchronized 那样普遍适用于实现线程安全。 案例A. 非线程安全的数值范围类@NotThreadSafe public class NumberRange { private volatile int lower, upper; public int getLower() { return lower; } public int getUpper() { return upper; } public void setLower(int value) { if (value &gt; upper) throw new IllegalArgumentException(...); lower = value; } public void setUpper(int value) { if (value &lt; lower) throw new IllegalArgumentException(...); upper = value; } }案例A 显示了一个非线程安全的数值范围类。 它包含了一个不变式 —— 下界总是小于或等于上界。这种方式限制了范围的状态变量，因此将 lower 和 upper 字段定义为 volatile 类型不能够充分实现类的线程安全；从而仍然需要使用同步。否则，如果凑巧两个线程在同一时间使用不一致的值执行 setLower 和 setUpper 的话，则会使范围处于不一致的状态。例如，如果初始状态是 (0, 5)，同一时间内，线程 A 调用 setLower(4) 并且线程 B 调用 setUpper(3)，那么两个线程都会通过用于保护不变式的检查，使得最后的范围值是 (4, 3) —— 一个无效值。至于针对范围的其他操作，我们需要使 setLower() 和 setUpper() 操作原子化 —— 而将字段定义为 volatile 类型是无法实现这一目的的。 性能考虑使用 volatile 变量的主要原因是其简易性：在某些情形下，使用 volatile 变量要比使用相应的锁简单得多。 使用 volatile 变量次要原因是其性能：某些情况下，volatile 变量同步机制的性能要优于锁。在目前大多数的处理器架构上，volatile 读操作开销非常低 —— 几乎和非 volatile 读操作一样。而 volatile 写操作的开销要比非 volatile 写操作多很多，因为要保证可见性需要实现内存界定（Memory Fence），即便如此，volatile 的总开销仍然要比锁获取低。volatile 操作不会像锁一样造成阻塞，因此，在能够安全使用 volatile 的情况下，volatile 可以提供一些优于锁的可伸缩特性。如果读操作的次数要远远超过写操作，与锁相比，volatile 变量通常能够减少同步的性能开销。 正确使用 volatile 的模式很多并发性专家事实上往往引导用户远离 volatile 变量，因为使用它们要比使用锁更加容易出错。然而，如果谨慎地遵循一些良好定义的模式，就能够在很多场合内安全地使用 volatile 变量。要始终牢记使用 volatile 的限制 —— 只有在状态真正独立于程序内其他内容时才能使用 volatile —— 这条规则能够避免将这些模式扩展到不安全的用例。 模式 #1：状态标志也许实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。很多应用程序包含了一种控制结构，形式为 “在还没有准备好停止程序时再执行一些工作”，如案例B 所示： 案例B. 将 volatile 变量作为状态标志使用volatile boolean shutdownRequested; ... public void shutdown() { shutdownRequested = true; } public void doWork() { while (!shutdownRequested) { // do stuff } }很可能会从循环外部（即在另一个线程中）调用 shutdown() 方法 ，因此需要执行某种同步来确保正确实现 shutdownRequested 变量的可见性。（可能会从 JMX 侦听程序、GUI 事件线程中的操作侦听程序、通过 RMI 、通过一个 Web 服务等调用）。然而，使用 synchronized 块编写循环要比使用 案例B 所示的 volatile 状态标志编写麻烦很多。由于 volatile 简化了编码，并且状态标志并不依赖于程序内任何其他状态，因此此处非常适合使用 volatile。这种类型的状态标记的一个公共特性是：通常只有一种状态转换；shutdownRequested 标志从 false 转换为 true，然后程序停止。这种模式可以扩展到来回转换的状态标志（从 false 到 true，再转换到 false），但是只有在转换周期不被察觉的情况下才能扩展。此外，还需要某些原子状态转换机制，例如原子变量。 模式 #2：一次性安全发布（one-time safe publication）缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原语值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值（由另一个线程写入）和该对象状态的旧值同时存在。（这就是造成著名的双重检查锁定（double-checked-locking）问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象）。实现安全发布对象的一种技术就是将对象引用定义为 volatile 类型。案例C 展示了一个示例，其中后台线程在启动阶段从数据库加载一些数据。其他代码在能够利用这些数据时，在使用之前将检查这些数据是否曾经发布过。 案例C. 将 volatile 变量用于一次性安全发布public class BackgroundFloobleLoader { public volatile Flooble theFlooble; public void initInBackground() { // do lots of stuff theFlooble = new Flooble(); // this is the only write to theFlooble } } public class SomeOtherClass { public void doWork() { while (true) { // do some stuff... // use the Flooble, but only if it is ready if (floobleLoader.theFlooble != null) doSomething(floobleLoader.theFlooble); } } }如果 theFlooble 引用不是 volatile 类型，doWork() 中的代码在解除对 theFlooble 的引用时，将会得到一个不完全构造的 Flooble。该模式的一个必要条件是：被发布的对象必须是线程安全的，或者是有效的不可变对象（有效不可变意味着对象的状态在发布之后永远不会被修改）。volatile 类型的引用可以确保对象的发布形式的可见性，但是如果对象的状态在发布后将发生更改，那么就需要额外的同步。 模式 #3：独立观察（independent observation）安全使用 volatile 的另一种简单模式是：定期 “发布” 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。使用该模式的另一种应用程序就是收集程序的统计信息。案例D 展示了身份验证机制如何记忆最近一次登录的用户的名字。将反复使用 lastUser 引用来发布值，以供程序的其他部分使用。 案例D. 将 volatile 变量用于多个独立观察结果的发布public class UserManager { public volatile String lastUser; public boolean authenticate(String user, String password) { boolean valid = passwordIsValid(user, password); if (valid) { User u = new User(); activeUsers.add(u); lastUser = user; } return valid; } }该模式是前面模式的扩展；将某个值发布以在程序内的其他地方使用，但是与一次性事件的发布不同，这是一系列独立事件。这个模式要求被发布的值是有效不可变的 —— 即值的状态在发布后不会更改。使用该值的代码需要清楚该值可能随时发生变化。 模式 #4：“volatile bean” 模式volatile bean 模式的基本原理是：很多框架为易变数据的持有者（例如 HttpSession）提供了容器，但是放入这些容器中的对象必须是线程安全的。在 volatile bean 模式中，JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。（这将禁止具有数组值的属性，因为当数组引用被声明为 volatile 时，只有引用而不是数组本身具有 volatile 语义）。对于任何 volatile 变量，不变式或约束都不能包含 JavaBean 属性。案例E 中的示例展示了遵守 volatile bean 模式的 JavaBean： 案例E. 遵守 volatile bean 模式的 Person 对象@ThreadSafe public class Person { private volatile String firstName; private volatile String lastName; private volatile int age; public String getFirstName() { return firstName; } public String getLastName() { return lastName; } public int getAge() { return age; } public void setFirstName(String firstName) { this.firstName = firstName; } public void setLastName(String lastName) { this.lastName = lastName; } public void setAge(int age) { this.age = age; } }volatile 的高级模式前面几节介绍的模式涵盖了大部分的基本用例，在这些模式中使用 volatile 非常有用并且简单。这一节将介绍一种更加高级的模式，在该模式中，volatile 将提供性能或可伸缩性优势。volatile 应用的的高级模式非常脆弱。因此，必须对假设的条件仔细证明，并且这些模式被严格地封装了起来，任何微小的改动都需要精准拿捏！高级模式的主要目标是提供更高的性能，因此开始应用高级模式之前，需要对这些模式进行权衡，放弃可读性或可维护性来换取可能的性能收益， 如果并不需要提升性能（或者不能够通过一个严格的测试程序证明需要它），那很可能得不偿失。 模式 #5：开销较低的读－写锁策略至此， volatile 的功能还不足以实现计数器。因为 ++x 实际上是三种操作（读、添加、存储）的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。然而，如果读操作远远超过写操作，您可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。 案例F 中显示的线程安全的计数器使用 synchronized 确保增量操作是原子的，并使用 volatile 保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 volatile 读操作，这通常要优于获取一个无竞争的锁的开销。 案例F. 结合使用 volatile 和 synchronized 实现 “开销较低的读－写锁”@ThreadSafe public class CheesyCounter { // Employs the cheap read-write lock trick // All mutative operations MUST be done with the &#39;this&#39; lock held @GuardedBy(&quot;this&quot;) private volatile int value; public int getValue() { return value; } public synchronized int increment() { return value++; } }之所以将这种技术称之为 “开销较低的读－写锁” 是因为使用了不同的同步机制进行读写操作。因为本例中的写操作违反了使用 volatile 的第一个条件，因此不能使用 volatile 安全地实现计数器 —— 必须使用锁。在这种模式中， 可以在读操作中使用 volatile 确保当前值的可见性，因此可以使用锁进行所有变化的操作，使用 volatile 进行只读操作。其中，锁一次只允许一个线程访问值，volatile 允许多个线程执行读操作，因此当使用 volatile 保证读代码路径时，要比使用锁执行全部代码路径获得更高的共享度 —— 就像读－写操作一样。然而，要随时牢记这种模式的弱点：如果超越了该模式的最基本应用，结合这两个竞争的同步机制将变得非常困难。 结束语与锁相比，Volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。如果严格遵循 volatile 的使用条件 —— 即变量真正独立于其他变量和自己以前的值 —— 在某些情况下可以使用 volatile 代替 synchronized 来简化代码。然而，使用 volatile 的代码往往比使用锁的代码更加容易出错。本文介绍的模式涵盖了可以使用 volatile 代替 synchronized 的最常见的一些用例。遵循这些模式（注意使用时不要超过各自的限制）可以帮助您安全地实现大多数用例，使用 volatile 变量获得更佳性能。","categories":[{"name":"技术","slug":"技术","permalink":"http://ajayhao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://ajayhao.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"TA数据交换信息速查","slug":"ta-bizcode","date":"2016-07-03T01:31:00.000Z","updated":"2016-07-03T01:31:00.000Z","comments":true,"path":"2016/07/03/ta-bizcode/","link":"","permalink":"http://ajayhao.github.io/2016/07/03/ta-bizcode/","excerpt":"根据《开放式基金业务数据交换协议（证监会2012-05-17 发布）》的业务类型编码整理而来，留备速查","text":"根据《开放式基金业务数据交换协议（证监会2012-05-17 发布）》的业务类型编码整理而来，留备速查 业务类型编码 申请业务代码 确认业务代码 业务名称 备注 001 101 开户 002 102 销户 003 103 账户信息修改 004 104 基金帐户冻结 005 105 基金帐户解冻 006 106 基金账户卡挂失 007 107 基金账户卡解挂 008 108 增加交易账户 009 109 撤销交易账户 020 120 认购 此时的确认无清算结果 021 121 预约认购 此时的确认无清算结果 022 122 申购 023 123 预约申购 此时的确认无清算结果 024 124 赎回 025 125 预约赎回 此时的确认无清算结果 026 126 转托管 027 127 转托管转入 028 128 转托管转出 029 129 设置分红方式 130 认购结果 发行结束时的认购情况 031 131 基金份额冻结 032 132 基金份额解冻 033 133 非交易过户 034 134 非交易过户转入 035 135 非交易过户转出 036 136 基金转换 037 137 基金转换转入 038 138 基金转换转(出) 039 139 定时定额申购 040 140 退款 041 141 补款 142 强行赎回 143 红利发放 144 强行调增 145 强行调减 146 配号 149 募集失败 150 基金清盘 151 基金终止 052 152 撤单 053 153 撤预约单 只撤预约赎回的申请 054 154 无效资金 155 基金销售人资金清算 156 投资人资金清算 157 红利解冻 058 158 变更交易账号 059 159 定期定额协议开通 060 160 定期定额协议撤销 061 161 定时定额申购修改 062 162 认购调整 063 163 定时定额赎回 067 167 基金联名卡开通 068 168 基金联名卡撤销 169 积分确认 070 地区编号变更通知 080 180 确权 088 188 基金质押 091 191、192 ETF基金申购 第一次确认金额和费用，第二次确认份额 093 193、194 ETF基金赎回 同申购 098 198 快速过户 TA与代理人交换的数据索引文件、数据文件列表其中“??”为TA代码，“XXX”为销售代理人代码。yyyymmdd为文件发送日期。 TA接收代理人文件： 汇总数据 发送方 文件名 索引文件 代理人 OFI_xxx_??_yyyymmdd.TXT 帐户申请 代理人 OFD_xxx_??_yyyymmdd_01.TXT 交易申请 代理人 OFD_xxx_??_yyyymmdd_03.TXT 其它类申请 代理人 OFD_xxx_??_yyyymmdd_23.TXT 业务申请汇总 代理人 OFD_xxx_??_yyyymmdd_13.TXT TA发送代理人文件： 汇总数据 发送方 文件名 说明 索引文件 代理人 OFJ_??_xxx_yyyymmdd.TXT 07/08/21文件的索引文件 基金行情 代理人 OFD_??_xxx_yyyymmdd_07.TXT 公告 代理人 OFD_??_xxx_yyyymmdd_08.TXT 参与人及结算席位文件 代理人 OFD_??_xxx_yyyymmdd_21.TXT -– -– -– -– 索引文件 代理人 OFS_??_xxx_yyyymmdd.TXT 11文件的索引文件 业务申请汇总 代理人 OFD_??_xxx _yyyymmdd_11.TXT -– -– -– -– 索引文件 代理人 OFI_??_xxx _yyyymmdd.TXT 02/04/05/06/09/12/24文件的索引文件 帐户回报 代理人 OFD_??_xxx_yyyymmdd_02.TXT 交易回报 代理人 OFD_??_xxx_yyyymmdd_04.TXT 份额对帐 代理人 OFD_??_xxx_yyyymmdd_05.TXT 基金分红 代理人 OFD_??_xxx_yyyymmdd_06.TXT 红利汇总 代理人 OFD_??_xxx_yyyymmdd_09.TXT 业务确认汇总 代理人 OFD_??_xxx_yyyymmdd_12.TXT 其它类确认 代理人 OFD_??_xxx_yyyymmdd_24.TXT -– -– -– -– 索引文件 代理人 OFK_??_xxx_yyyymmdd.TXT 25/10资金类文件的索引文件 资金清算文件 代理人 OFD_??_xxx_yyyymmdd_25.TXT 日交割汇总 代理人 OFD_??_xxx_yyyymmdd_10.TXT -– -– -– -– 索引文件 代理人 OFC_??_xxx _yyyymmdd.TXT C1/C2/C3/C4/C5文件的索引文件 基金基础参数 代理人 OFD_??_xxx_yyyymmdd_C1.TXT 基金代理关系 代理人 OFD_??_xxx_yyyymmdd_C2.TXT 基金转换关系 代理人 OFD_??_xxx_yyyymmdd_C3.TXT 基金分红方案 代理人 OFD_??_xxx_yyyymmdd_C4.TXT 基金费率 代理人 OFD_??_xxx_yyyymmdd_C5.TXT 文件类型与业务类型对应关系表 文件类型 业务类型 01：账户申请 开户申请(001)，账户信息修改申请(003) - 销户申请(002)，撤销交易账户申请(009) - 增加交易账户申请(008)，变更交易账号（058） 02：账户确认 开户确认(101) - 销户确认(102)，账户信息修改确认(103)，增加交易账户确认(108)，变更交易账号确认(158)，撤销交易账户确认(109) 03：交易申请 认购申请(020) - 申购申请(022) ，定时定额申购申请(039)，ETF申购申请(091) - 赎回申请(024)，预约赎回申请(025)，定时定额赎回申请(063)，ETF赎回申请(093) - 转销售人/机构申请(026)，转销售人/机构转入申请(027)，转销售人/机构转出申请(028) - 设置自动再投资申请(029) - 基金份额冻结申请(031) - 基金份额解冻申请(032) - 基金转换申请(036)，基金转换转入申请(037)，基金转换转出申请(038) - 撤预约单(053) - 定时定额申购开通申请（059），定时定额申购撤销申请（060），定时定额变更申请（061） - 认购调整申请(062) - 基金质押申请（088），快速过户申请（098） 04：交易确认 认购确认(120) - 申购确认(122)，定时定额申购确认(139)，ETF申购一次确认(191)，ETF申购二次确认(192) - 赎回确认(124)，强行赎回确认(142) ，定时定额赎回确认(163)，ETF赎回一次确认(193)，ETF赎回二次确认(194) - 预约赎回确认(125) - 转销售人/机构确认(126)，转销售人/机构转入确认(127)，转销售人/机构转出确认(128) - 设置自动再投资确认(129) - 认购结果(130) - 基金份额冻结确认(131) - 基金份额解冻确认(132) - 基金红利解冻确认(157) - 非交易过户转入确认(134)，非交易过户转出确认(135) - 基金转换转入确认(137) - 基金转换转出确认(138) - 撤预约单确认(153) - 强行调增(144) ，强行调减(145) - 认购调整确认(162)，定时定额申购开通确认（159），定时定额申购撤销确认（160），定时定额变更确认（161） - 基金质押确认（188），快速过户确认（198） - 募集失败（149），基金清盘（150），基金终止（151） 05：基金账户对帐 基金账户对帐数据 06：基金分红 红利/红利再投资发放(143) 07：基金和净值数据 基金信息数据项 08：公告 公告 09：红利汇总 红利汇总数据 10：日交割汇总 日交割汇总数据 11：业务申请汇总 业务申请汇总数据 12：业务确认汇总 业务确认汇总数据 21：参与人及结算席位文件 参与人及结算席位数据 23：其它类申请 确权申请(080)，基金联名卡开通申请（067），基金联名卡撤销申请（068）地区编号变更通知（070） 24：其它类确认 确权确认(180)，基金联名卡开通确认（167），基金联名卡撤销确认（168）积分确认（169） 25：资金清算 资金清算 交易处理返回代码的取值及含义 返回代码 返回信息 备注 0000 成功 0001 份数余额不足 0002 账户已冻结 0003 账户已挂失 0004 发行期不受理 0005 封闭期不受理 0006 非开放日不受理 0007 收到预约数据确认 0008 巨额不受理 0009 无此账户 0010 其它原因失败 0100 证件号码错误 包括无证件号码 0101 证件号码重复 0102 地区号无效 0103 业务种类非法 0104 销售人交易基金账号非法 0105 销售代理人代码错误 0106 无户名 0107 个人/法人标志非法 0108 证件类型非法 0109 无经办人姓名 0110 经办人证件类型非法 包括无经办人证件号码 0111 经办人证件号码错误 0112 无通讯地址 0113 邮政编码非法 包括无邮政编码 0114 无电话 0115 无住址电话 0116 无单位电话 0117 开户网点非法 0118 冻结挂失截止日期无效 0119 无E-MAIL地址 0120 无法人代表姓名 0121 法人代表证件类型非法 0122 法人身份证件代码非法 包括无法人身份证件代码 0123 基金账号非法 包括无基金账号 0124 密函编号非法 包括无密函编号 0125 职业代码非法 0126 学历代码无效 0127 年收入代码 0128 性别非法 0129 出生日期非法 0130 传真号码非法 0131 手机号码非法 0132 传呼机号码非法 0133 交收行代码非法 0134 交收行账户名非法 0135 交收行账号非法 0136 上交所账号非法 0137 深交所账号非法 0138 开户日期非法 0139 申请单编号非法 包括无申请单编号 0140 冻结标志非法 0141 默认分红方式非法 0200 基金代码非法 0201 交易日期非法 0202 交易时间非法 0203 销售人流水号非法 0204 币种代码非法 0205 资金账号非法 0206 交易数量非法 0207 交易金额非法 0208 对方销售人基金账号非法 0209 受理日期已变为下一个工作日 0210 对方基金账号非法 0211 过户代理地点代码非法 0212 股东账户代码非法 0213 指定券商席位号非法 0214 预约赎回日期非法 0215 网点号非法 0216 折扣率非法 0217 有效天数非法 0218 原申请单编号非法 0219 巨额赎回处理标志非法 0220 冻结原因非法 0221 对方网点号非法 0222 再投资类型非法 0223 目标基金代码非法 0224 手续费率非法 0225 手续费非法 0226 对方销售人代码非法 0227 原申购日期非法 0228 账户未挂失 0229 账户未冻结 0301 账户申请日期无效 0302 账户申请不存在 0303 投资人已注册基金账户 0304 账户申请注册失败 0305 赎回份数过小 0306 因投资人未在转入方开户致使转销售人/机构失败 0307 持有份数超过持有上限 0308 基金账户已注销 0309 单笔申购低于申购下限 0310 赎回后剩余份数低于持有下限 0311 转出方余额不足 0312 确认异常 0313 投资人名或证件类型或证件代码与股东资料不符 0314 基金账户已挂账 0315 证券账户不存在 0316 基金账户不存在 0317 基金非认购期 0318 基金非申购期 0319 基金非赎回期 0320 基金禁止转销售人/机构 0321 证券账户已注册为基金账户 0322 基金账户有转托基金的冻结份数能单只基金全部转销售人/机构 0323 有在途份数，不能全转销售人/机构 0324 转出方余额为零 0325 原申请日期无效 0326 转入转出是同一代理人 0327 销售代理人不能代理此基金 0328 销售代理人无效 0329 性别代码无效 0330 申请日期无效 0331 投资人名无效 0332 投资人证件类型无效 0333 投资人证件号码无效 0334 通讯地址无效 0335 法人代表姓名无效 0336 经办人姓名无效 0337 单笔认购低于认购下限 0338 单笔认购高于认购上限 0339 基金处于权益分配期间，不允许更改分红方式 0340 单笔赎回高于预约下限 0341 单笔赎回低于赎回下限 0342 取基金信息错误 0343 写权益登记错误 0344 写基金明细表出错 0345 撤单申请无效 0346 转销售人/机构类型错 0347 转销售人/机构类型与申报数据不符 0348 旧基金账号个人资料不存在 0349 旧基金账号机构资料不存在 0350 无效分红方式 0351 该基金账号有份数允许注销 0352 赎回金额不足以支付手续费 0353 证券账户类型非法 0354 同一网点申报相同数据 0355 管理人拒绝 0356 管理人配售确认撤销 0357 认购金额过少 0358 经办人识别方式非法 0359 CALLCENTER交易标志非法 0360 INTERNET交易标志非法 0361 账单寄送选择方式非法 0362 有基金份数，消户非法 0363 基金账号信息未作改动, 拒绝申请 0364 基金账号凭证号非法 0365 有当日申请，销户非法 0366 基金净值非法 0367 转销售人/机构中转出与转入交易账户的基金账户不同 0368 基金不能转入 0369 基金不能转出 0370 持有份数小于最低持有份数, 应全部赎回或转换 0371 税率非法 0372 分红方案错误 0373 基金发行失败，退回认购 0374 该预约赎回单已失效 0375 手续费分成非法 0376 基金终止 0377 基金不在发行期或认购结束，认购不受理 0378 基金在正常交易期 0379 基金已发行或发行失败 0380 基金停止交易 0381 基金停止申购 0382 基金停止赎回 0383 基金正在权益登记 0384 红利发放，业务不受理 0385 无法识别的基金状态 0386 非交易过户对方账号未登记 0387 本日有冻结、挂失申请，交易无效 0388 一天仅接受一次重要资料修改 0389 分红期间有在途权益，不能处理 0390 基金账号已登记 0391 基金账号未登记 0392 该交易账号已开户 0393 有重复的冻结申请 0394 非交易过户必须逐笔确认 0395 交易后，入方余额低于最低限制 0396 交易后，出方余额低于最低限制 0397 基金转换对方基金停止交易 0398 基金无份数可冻结解冻 0399 无此冻结申请 0400 解冻份数与原冻结数不匹配 0401 超过最高赎回份数限制 0402 申购金额低于手续费 0403 总份额已超过募集金额，不能再认购 0404 按份数认购，金额计算错误 0405 不允许机构认购 0406 不允许个人认购 0407 逐笔人工处理为无效 0408 逐笔人工处理为成功 0409 已撤单 0410 巨额赎回延续部分 0411 重复开户 0412 不支持预约申请 0413 有份数冻结，不允许账户冻结 0414 没有指定赎回的基金份数 0415 小于初次投资金额限制 0416 小于追加投资限制 0417 转销售人/机构对方销售商或网点不存在 0418 不能修改客户类型 0419 重要资料修改当天不能赎回转销售人/机构 0420 申请日期大于最后认购日期 0421 巨额赎回，不能基金转换 0422 当天多次开户(交易账号重) 0423 当天多次开户(基金账号重) 0424 不存在要转出的份数 0425 经办人识别方式非法 0426 账单寄送选择方式非法 0427 基金账号信息未作改动, 拒绝申请 0428 持有份数小于最低持有份数, 应全部赎回或转换 0429 分红方案错误 0430 该预约赎回单已失效 0431 持有份数小于等于最低赎回份数, 应全部赎回或转换 0432 基金在个人认购期，不接受机构认购 0433 基金在机构认购期，不接受个人认购 0434 认购金额小于机构最低认购金额 0435 认购申请金额小于个人最低认购金额 0436 认购金额大于机构最高认购金额 0437 认购申请金额大于个人最高认购金额 0438 基金处于不允许申购状态 0439 申购申请金额小于机构最低追加投资金额 0440 申购申请金额小于个人最低追加投资金额 0441 申购申请金额小于机构最低首次投资金额 0442 申购申请金额小于个人最低首次投资金额 0443 定时定额申购申请金额小于最低定额 0444 定时定额申购申请金额超出最低定额部分不是级差的整数倍 0445 定时定额申购合约终止 0446 定时定额申购金额与原合约不符 0447 持有份数大于最低赎回份数, 申请赎回份数不小于最低赎回份数 0448 柜员登录注销错误 0449 柜员代码不能为空 0450 没有此柜员 0451 此柜员已被冻结 0452 此柜员已被删除 0453 柜员密码不符 0454 此柜员已经登录系统;或者此前非正常退出系统，请与系统管理员联系 0455 登录柜员记录出现异常，请与系统管理员联系 0456 注销柜员状态出现异常，请与系统管理员联系 0457 操作员过期 0458 柜员管理类错误 0459 柜员代码长度必须为3位 0460 此柜员代码已经存在 0461 柜员姓名不能为空 0462 存在同名的有效柜员，系统不允许姓名重复 0463 柜员密码不能为空 0464 柜员所属部门不能为空 0465 有效天数必须是大于0的整数 0466 起始日期不能为空 0467 确认密码不能为空 0468 组代码不能为空 0469 组的成员已经存在 0470 权限代码不能为空 0471 组的权限已经存在 0472 柜员的权限已经存在 0473 组名称不能为空 0474 此组已经存在 0475 柜员角色不能为空 0476 组非空不能删除 0477 组的成员不存在 0478 组的权限不存在 0479 根用户不能删除 0480 操作员代码不能为空 0481 没有此组 0482 此柜员代码不存在 0483 确认密码不正确 0484 修改柜员资料时柜员状态不允许被设置为”删除” 0485 柜员已被删除，操作被禁止 0486 柜员处于活动状态，操作被禁止 0487 交易密码错误 0488 交易账号凭证号错误 0489 交易账户处于等待确认状态 0490 交易账户已挂失 0491 确认密码不正确 0492 基金账户处于等待确认状态 0493 当天有账户申请 0494 当天有交易申请 0495 案号非法 0496 该交易申请已经提交 0497 定时定额申购日期非法 0498 定时定额申购类型错误 0499 定时定额申购状态非法 0500 该定时定额申购已完成 0501 该定时定额申购已撤单 0502 该定时定额申购已撤消 0503 定时定额申请不存在或其它数据库错误 0504 解冻份数大于已冻结份数 0505 在同一工作日同一投资者有相同的更改基金分红方式申请 0506 交易账户已作废 0507 交易账户凭证号状态错误 0508 交易账户已销户 0509 交易账户已冻结 0510 交易账户已撤销 0511 交易账户待确认 0512 交易账户未开基金账户 0513 基金账户挂失 0514 基金账户冻结 0515 基金账户销户 0516 转销售人/机构对方机构代码与发起机构代码相同 0517 基金转换转出基金与目标基金相同 0518 交易账户与基金账户不匹配 0519 禁止此模式基金转换 0520 存在逆向基金转换 0521 无要复核的申请合同号 0522 要复核的合同号不属于本机构 0523 要复核的合同号不属于本网点 0524 要复核的合同号业务类型不一致 0525 复核人员与受理人员相同 0526 要复核的合同号已复核 0527 要复核的合同号已作废 0528 要复核的合同号已撤单 0529 复核流水的基金代码不对 0530 复核流水的申请金额不对 0531 复核流水的交易账号不对 0532 写更改申请流水的复核标志失败 0533 复核流水的操作员代码不对 0534 复核流水的申请份数不对 0535 复核流水的巨额赎回处理方式不对 0536 复核流水的对方机构代码不对 0537 复核流水的转换目标基金代码不对 0538 复核流水的申请费用不对 0539 复核流水的分红方式不对 0540 复核流水的分红比例不对 0541 无此交易码 0542 该操作现不可用 0543 该申请已撤单 0544 该申请已作废 0545 该申请还未复核 0546 电话委托受理业务不能通过柜面撤单 0547 该申请已复核 0548 系统通用参数查询失败 0549 查询表单列值信息失败 0550 查询报表输出固定数据配置信息失败 0551 查询表单输入条件的配置信息失败 0552 未定义的表单查询 0553 查询表单数据集信息失败 0554 请选择输入查询表单号 0555 未定义的查询类别 0556 查询表单数据集信息失败 0557 取申请账页失败 0558 发布日期不能为空 0559 利率生效时间非法 0560 利率非法 0561 利息税率非法 0562 实施时间不能为空 0563 最小手续费比率不能小于0 0564 最大手续费比率不能大于1 0565 最小手续费比率不能大于最大手续费比率 0566 注册登记人手续费分成比率不能为空 0567 此业务不能设置进入基金资产手续费比率 0568 手续费分成比率不能大于最小手续费比率 0569 手续费分成比率不能小于0 0570 权益登记日非法 0571 除权日非法 0572 派息日非法 0573 利得比例不能为空 0574 利得比例必须在0, 1之间 0575 分红方案编码非法 0576 费率方案编号不能为空 0577 手续费计算方案起始时间非法 0578 基金名称不能为空 0579 基金状态非法 0580 基金转换状态非法 0581 基金认购价格非法 0582 费率方案不完整 0583 存在未确认记录,不能提交 0584 此操作员未输入费率方案, 不能输入费率 0585 金额非法 0586 持有天数非法 0587 手续费率段重叠 0588 此操作员未输入费率方案, 不能删除费率 0589 基金账户受理方式不能为空 0590 不存在的基金账户受理方式 0591 到账情况不能为空 0592 证件唯一性不能为空 0593 系统状态不能为空 0594 强行签退时间不能为空 0595 强行签退持续时间不能为空 0596 强行签退持续时间不能小于0 0597 基金净值路径不能为空 0598 销售点代码不能为空 0599 清算日期不能为空 0600 工作日期不能为空 0601 巨额赎回比例不能为空 0602 巨额赎回比例必须在0-1之间 0603 未知的系统参数 0604 定时定额申购日期不能为 0605 按定时定额申购日期错 0606 印花税率非法 0607 审批日期不能为空 0608 审批人不能为空 0609 审批数量不能为空 0610 审批数量不能小于0 0611 批准的基金转换份数应小于等于基金总份数 0612 待确认的记录超过一条 0613 确认审批内容与第一次输入内容不符 0614 不支持的基金发行方案 0615 待确认的基金发行记录超过一条 0616 到款日期不能为空 0617 预售规模不能为空 0618 预售规模不能小于0 0619 认购价格不能小于0 0620 销售机构设置错误 0621 销售机构接收目录不能为空 0622 销售机构发送目录不存在 0623 销售机构接收目录不能为空 0624 销售机构接收目录不存在 0625 销售机构代码不能为空 0626 销售机构名称不能为空 0627 销售机构状态不能为空 0628 销售机构类型不能为空 0629 销售机构接受目录长度大于120 0630 销售机构发送目录长度大于120 0631 网点代码不能为空 0632 网点名称不能为空 0633 区域代码不能为空 0634 区域代码不存在 0635 银行名称不能为空 0636 银行状态不能为空 0637 公告状态不能为空 0638 公告已输入,未复核 0639 公告已复核成功 0640 未定义的公告状态 0641 此公告不存在 0642 公告标题不能为空 0643 公告日期不能为空 0644 公告日期不能比当前日期小 0645 公告内容不能为空 0646 公告类型不能为空 0647 取公告编号流水号失败 0648 操作员相同,不能复核公告 0649 操作员不同,不能修改公告 0650 公告已经发布 0651 公告复核错误 0652 不支持的传输状态 0653 未解上传包 0654 未打包上传包 0655 未解下传包 0656 未打包下传包 0657 包传输状态不存在 0658 第一次输入 0659 第一次删除 0660 第一次修改 0661 未生效 0662 已生效 0663 已实施 0664 未知状态 0665 记录只有一条 0666 记录不存在 0667 记录多于一条 0668 不是本操作员输入,不能修改, 请先清屏 0669 本操作员输入,不能再次输入 0670 不是本操作员输入,不能删除 0671 第二次输入内容与第一次输入内容不符 0672 第二次修改内容与第一次修改内容不符 0673 数据库错误 0674 写日志失败 0675 取交易账户编号失败 0676 取基金账户流水号失败 0677 取系统日期失败 0678 存在认购或未完成的赎回申请 0679 清算步骤错误 0680 取系统时间失败 0681 取参数ACCPTMD(受理方式)的值失败 0682 取交易账号凭证流水号失败 0683 取销售机构代码失败 0684 存在冻结的基金份数 0685 正在清算, 不能处理到账操作 0686 存在未审批的巨额赎回 0687 取交易账号凭证号失败 0688 取交易账号失败 0689 取交易密码失败 0690 取基金余额失败 0691 更改余额失败 0692 写资金回款流水失败 0693 交易清算类型错误 0694 取清算日失败 0695 修改投资者基金分红信息失败 0696 取市场标志失败 0697 市场标志错误 0698 现为收市状态，还未日初，不能进行业务受理 0699 现为日终状态，还未日初，不能进行业务受理 0700 系统步骤错误 0701 取市场状态描述错误 0702 设置市场状态错误 0703 设置下一工作日错误 0704 生成工作日表错误 0705 系统日初错误 0706 系统日终错误 0707 设置上一工作日错误 0708 取收市处理状态失败 0709 收市处理步骤错误 0710 取收市处理状态描述失败 0711 设置收市处理状态失败 0712 收市初始化错误 0713 收市复核错误 0714 收市写账页错误 0715 取系统状态失败 0716 取系统状态描述失败 0717 设置系统状态失败 0718 系统当前状态不允许操作 0719 取清算处理状态失败 0720 清算处理步骤错误 0721 取清算处理状态描述失败 0722 设置清算处理状态失败 0723 清算初始化错误 0724 清算数据备份错误 0725 清算数据恢复错误 0726 账户清算错误 0727 交易清算错误 0728 清算复核错误 0729 清算结束错误 0730 预清算错误 0731 清算数据汇总错误 0732 审批赎回份数大于允许的最大审批份数 0733 审批申购份数大于允许的最大审批份数 0734 基金未发生巨额或超规模不用进行审批 0735 基金发生巨额或超规模请进行审批 0736 取募集期日处理状态失败 0737 募集期日处理步骤错误 0738 取募集期日处理状态描述失败 0739 设置募集期日处理状态失败 0740 募集期日处理初始化错误 0741 募集期日处理数据备份错误 0742 募集期日处理数据检查错误 0743 募集期日处理当日有效认购统计错误 0744 募集期日处理错误 0745 募集期日处理发行统计错误 0746 募集期日处理数据汇总错误 0747 募集期日处理复核开始错误 0748 募集期日处理复核结束错误 0749 募集期日处理数据恢复错误 0750 募集期日处理结束错误 0751 基金认购费率未设置或无有效费率 0752 基金交易费率未设置或无有效费率 0753 基金NAV值未设置或无有效NAV值 0754 没有基金可进行募集处理 0755 取发行处理状态失败 0756 发行处理步骤错误 0757 取发行处理状态描述失败 0758 设置发行处理状态失败 0759 发行处理初始化错误 0760 发行处理数据备份错误 0761 发行处理错误 0762 发行处理复核开始错误 0763 发行处理复核结束错误 0764 发行处理数据恢复错误 0765 发行处理结束错误 0766 发行预处理错误 0767 计算发行利息错误 0768 发行失败处理错误 0769 发行成功处理错误 0770 利率未设置或不存在 0771 没有基金可进行发行处理 0772 分红方案非法 0773 分红方案状态错误 0774 取投资者分红信息错误 0775 计算投资者分红权益错误 0776 权益登记错误 0777 红利发放错误 0778 红利统计错误 0779 统计认购清算确认数据错误 0780 统计认购数据(给核算)错误 0781 统计发行确认数据错误 0782 统计发行确认数据(给核算)错误 0783 汇总业务申请数据错误 0784 汇总业务确认数据错误 0785 汇总统计固定收费错误 0786 读数据库失败，请查看错误日志 0787 写数据库错误，请查看错误日志 0788 数据操作失败，请查看系统日志 0789 写交易申请流水失败 0790 写账页失败 0791 数据历史备份与清除失败 0792 按申请编号检查申请数据错误 0793 按基金状态检查申请数据错误 0794 按申请数量检查申请数据错误 0795 写确认流水错误 0796 累计投资者认购金额错误 0797 写认购队列错误 0798 更改申请流水处理状态错误 0799 系统错误 0900 基金帐号已存在，不能再开户 0901 本日有冻结、挂失申请，交易无效 0902 帐户还有份额，不能销户 0903 金额超出最高持有比例 0904 帐户类申请，缺少关键数据！ 0905 开户、修改客户资料数据不全！ 0907 基金暂停赎回或转换 0908 基金暂停申购 0910 基金帐号非正常 0911 基金不在认购期 0919 冻结缺少截止日期！ 0920 证件类型、证件号码和客户类型不符 0921 一天仅接受一次重要资料修改 0922 分红期间有在图权益，不能处理 0923 证件号码重复 0924 非本TA数据 0925 还有其它未处理的交易，不能销户 0926 基金帐号预分配区段不正确 0927 基金帐号已登记 0928 基金帐号未登记 0929 该交易账号已开户 0930 修改分红方式错误 0931 封闭期不能赎回 0932 最后交易日不允许此交易 0933 基金帐号已销户 0934 基金帐号未冻结 0935 TA审核未确认 0936 有重复的冻结申请 0937 非交易过户必须逐笔确认 0938 非交易过户对方帐号状态非正常 0939 转托管入无对应的转出 0940 转托管对方销售商或网点必须不同 0941 分红前后不接受相应申请 0942 交易后，入方余额低于最低限制 0943 交易后，出方余额低于最低限制 0944 基金转换对方基金停止交易 0945 基金转换不属于同一基金管理人 0946 基金无份额可冻结解冻 0947 无此冻结申请 0948 解冻份额数与原冻结数不匹配 0949 认购或申购金额必须大于零 0950 超过最高赎回份额限制 0951 交易金额低于手续费 0952 总份额已超过募集金额，不能再认购 0953 按份额认购，金额计算错误 0954 认购额度已满 0955 不满足认购上下额限制 0956 不允许机构认购 0957 不允许个人认购 0958 赎回份额低于最低赎回份额限制 0959 可确认金额为0 0960 逐笔人工处理为无效 0961 逐笔人工处理为成功 0962 已撤单 0963 撤单失败 0964 巨额赎回延续部分 0965 赎回比例为0 0966 重复开户 0967 销售商没有开户权限 0968 原冻结申请不存在 0969 不支持预约申请 0970 有份额冻结，不允许账户冻结 0971 没有指定赎回的基金份额 0972 小于初次投资金额限制 0973 小于追加投资限制 0974 转托管对方销售商或网点不存在 0975 不能修改客户类型 0976 不支持的冻结类型 0977 无效的费率折扣 0978 重要资料修改当天不能赎回转托管 0979 申请日期大于最后认购日期 0980 巨额赎回，不能基金转换 0981 基金账号预分配长度不正确 0982 基金帐号预分配投资者类型不正确 0983 当天多次开户(交易账号重) 0984 当天多次开户(基金账号重) 0985 不存在要转出的份额 0986 无效的客户类型 0987 不存在对应的转出份额 9001 不支持的账户类型 9002 该基金不支持这种份额类别 9003 该销售商不支持这种份额类别 9004 该交易不能动用承诺优惠份额 9005 该业务不能由销售商发起 9007 不支持金额赎回 9008 基金账号预分配，账号未填 9009 不支持的转托管方式 9010 基金转换，不能转成相同基金 9011 指定赎回条件不匹配 9012 违反最底持有限制 9013 该销售机构不能销售本基金 9014 客户18岁以下不允许开户 9015 此客户在黑名单中的级别不允许开户 9016 黑名单用户，禁止此交易 9017 无效的人工确认比例 9018 人工确认比例为零 9019 基金转换份额类别不相同’ 9020 小于定期定额限制’ 9021 这两个基金之间不能进行转换 9022 交易帐号不能为空 9023 定期定额申购金额与协议不符’ 9024 N天后还没转托管入 9025 该协议号已经存在 9026 协议号不能为空 9027 解冻只能在原冻结发起方进行 9028 保本基金不允许修改分红方式 9029 保本基金不能申购 9030 保本基金不能基金转换入 9031 不支持指定赎回 9032 主交易帐号不允许销交易账号 9033 账户登记交易账号不能为空 9999 其它错误","categories":[{"name":"金融业务","slug":"金融业务","permalink":"http://ajayhao.github.io/categories/%E9%87%91%E8%9E%8D%E4%B8%9A%E5%8A%A1/"}],"tags":[{"name":"TA","slug":"TA","permalink":"http://ajayhao.github.io/tags/TA/"},{"name":"基金业务","slug":"基金业务","permalink":"http://ajayhao.github.io/tags/%E5%9F%BA%E9%87%91%E4%B8%9A%E5%8A%A1/"}]},{"title":"会计核算框架","slug":"accounting-framework","date":"2016-06-22T14:31:00.000Z","updated":"2016-06-22T14:31:00.000Z","comments":true,"path":"2016/06/22/accounting-framework/","link":"","permalink":"http://ajayhao.github.io/2016/06/22/accounting-framework/","excerpt":"比较下证券投资基金与保险的会计核算框架大致差异","text":"比较下证券投资基金与保险的会计核算框架大致差异 证券投资基金会计核算框架 发行成立，资金从实收基金进入银行存款。 运作过程中，从实收基金和损益平准金产生应收申购款，应收申购款最终进入银行存款。 运作过程中缴纳的各类备付金保证金，从银行存款支出。 运作进行各类投资，从银行存款变成各类资产。1) 直接从银行存款支付的品种，资金科目为银行存款2) 交易所交易的股票债券等（T+1交收），资金科目为证券清算款，在T+1交收时，将交收净额结转到银行存款。 持有投资品种过程中，形成的应收股利、应收利息，最终进入银行存款。 持有投资品种过程中，由于价格变化产生各种损益。 运作过程中产生的各种费用，应付费用对应产生损益类费用支持。支付的时候，从银行存款支付。 期末结转的时候，各类损益进入当期利润；当期利润再进入利润分配。 权益分配的除权日，从利润分配进入应付利润。 权益分配的红利到账日，现金红利从银行存款支付，减少应付利润。 权益分派的红利再投日，增加实收基金和损益平准金，减少应付利润。 产品赎回时，减少实收基金和损益平准金，增加应付赎回款。最终从银行存款进行支付。 保险资金会计核算内框架 保费流入成为投资资金进入银行存款；保费流出从投资资金划出，银行存款减少。对端科目为实收资金或者内部往来。 投资过程中缴纳的各类备付金保证金，从银行存款支出。 进行各类投资，从银行存款变成各类资产。直接从银行存款支付的品种，资金科目为银行存款；交易所交易的股票债券等（T+1交收），资金科目为证券清算款，在T+1交收时，将交收净额结转到银行存款。 持有投资品种过程中，形成的应收股利、应收利息，最终进入银行存款。 持有投资品种过程中，由于价格变化等原因产生各种损益。 投资过程中产生的各种费用，应付费用对应产生损益类费用支持。支付的时候，从银行存款支付。 回购首期：回购融入资金进入银行存款。回购末期：银行存款冲抵卖出回购负债。可参看前面回购业务介绍文章。 期末结转的时候，各类损益进入未分配利润。 两者差异1 资金进出不一样。基金资产为投资者参与投资的钱。保险资金为从保费中划入投资部分的资金。2 基金资产投向不区分投资类型。保险资金投向区分投资类型。各投资类型不同的账务处理可参考前面文章。3 损益结转处理不一样。4 结转收益","categories":[{"name":"金融业务","slug":"金融业务","permalink":"http://ajayhao.github.io/categories/%E9%87%91%E8%9E%8D%E4%B8%9A%E5%8A%A1/"}],"tags":[{"name":"会计核算","slug":"会计核算","permalink":"http://ajayhao.github.io/tags/%E4%BC%9A%E8%AE%A1%E6%A0%B8%E7%AE%97/"}]},{"title":"J2EE代码结构推荐","slug":"suitable-struct","date":"2016-05-29T04:09:00.000Z","updated":"2016-05-29T04:09:00.000Z","comments":true,"path":"2016/05/29/suitable-struct/","link":"","permalink":"http://ajayhao.github.io/2016/05/29/suitable-struct/","excerpt":"J2EE项目一般都有比较类似的目录层次，有了maven后，项目的大框架已经有了一种默认规约，而一个清晰良好的目录结构，能够为后续项目的“健康发展”提供很重要的支持。在一个结构良好的代码框架下，既能快速定位资源，便于日常维护，提升开发效率，又能使新的开发成员快速熟悉模块关联，便于开发团队新老交替，技术传承。","text":"J2EE项目一般都有比较类似的目录层次，有了maven后，项目的大框架已经有了一种默认规约，而一个清晰良好的目录结构，能够为后续项目的“健康发展”提供很重要的支持。在一个结构良好的代码框架下，既能快速定位资源，便于日常维护，提升开发效率，又能使新的开发成员快速熟悉模块关联，便于开发团队新老交替，技术传承。 传统SSH类项目的分层结构已经老生常谈，主要是Action-Service-DAO，可以参考吴毅先生的博文 JAVA中Action层, Service层 ，modle层 和 Dao层的功能区分 下图是典型的基于maven的SpringMVC+Mybatis的项目结构 从图中看已经做了比较好的分层，controller负责与前端交互，service负责模块业务逻辑，dao负责数据访问，mapper层为对象模型。 实践下来，一般规模的项目基于这个分层模型，应该已经足够，但是如果项目足够大，这样的划分就显得“不够友好”了。随着系统逐步庞大，模块间的业务逻辑调用势必藤蔓相连，会显得越来越“重”。我们尝试做下优化: 优化1：单一服务层-&gt;服务依赖隔离红框中的服务层，很可能出现负载过重的情况。因为服务接口作为对外的调用约定，具体业务逻辑均体现在ServiceImpl中，实际上就包括了两部分内容： 1. 组装业务模块DAO的返回POJO数据，并完成相应处理，实现自身业务模块的逻辑（“自身”指对于无需依赖外部接口的场景） 2. 整合调用外部服务接口（需要与外部系统/外部模块交互）这样的话，service层就会变得比较臃肿，比较好的做法是把1与2拆分开。在service中抽出facade层与intergration层。facade层作为留给外部模块调用的接口层，而intergration层作为一个访问其他服务的代理，继而将模块的内部逻辑与外部服务依赖加一层隔离。 如图所示，integration中的代理类负责内外交互，facade的实现类可以访问唯一的访问代理，而不用直接访问外部服务，IUserClientProxy起到了良好的“内外层服务隔离”效果。 优化2：单一模型层-&gt;DO + DTO 如图所示，dao层返回的POJO, 若直接穿透到controller层与viewer交互，无疑会出现实体对象的跨层耦合，这样便无法做到后台的改动对于前台透明。 为避免这样的情况发生，可以考虑在facade层增加DTO层，在DO数据需要被“跨层访问”时，进行适当的转换。 优化3: 把业务模块做成maven子模块 核心思想是把业务层的逻辑，能按照业务模块维度单独打包成jar包，便于更灵活的版本发布、弹性扩容以及缺陷管理。web的打包形式为war，业务层的maven module一律打包成jar，带上版本号，标识成web的依赖。后续可以针对单独的业务模块jar包进行管理。 这样调整后，可以作为较为理想的j2ee分层目录结构分层参考。 在我们团队中，电商项目及运营后台均沿用这样一种分层结构风格，或许对于一些小型项目，也不用划分的那么细。 可从长远的可扩展角度看，这种目录组织方式在模块解耦合上效果很好，使整个项目“能屈能伸”。","categories":[{"name":"技术","slug":"技术","permalink":"http://ajayhao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"J2EE","slug":"J2EE","permalink":"http://ajayhao.github.io/tags/J2EE/"}]},{"title":"应对多套git环境的ssh-key管理方案","slug":"git-sshkey","date":"2016-04-26T11:09:00.000Z","updated":"2016-04-26T11:09:00.000Z","comments":true,"path":"2016/04/26/git-sshkey/","link":"","permalink":"http://ajayhao.github.io/2016/04/26/git-sshkey/","excerpt":"每个程序员都有会不止一套Git环境的访问需求，不是现在，就是不远的将来。。。","text":"每个程序员都有会不止一套Git环境的访问需求，不是现在，就是不远的将来。。。 还在脱密期，已感受到了新东家的热(hou)情(ji)，包括工作邮箱、vpn、git等环境已邮件告知，能远程办公这点比起现在倒是人性化了些，要再能不上班在家干活就更好了 （老婆：纳尼！干毛活！在家就是我的！！）（老板：周末在家干活行，平时？想多了吧！） 走http协议拉了个代码，每次切换分支都要输入口令进行验证，后续写起代码提交勤快了还了得？。。由于家中已配置了GitHub的SSH key，如何集成公司的GitLab环境的SSH key，使同时用GitHub与公司GitLab时能走不同的key，免去频繁的口令验证呢？下面介绍两种管理多套环境的key的方法 友情提示：Windows平台下的童鞋，以下操作请到Cygwin/msysGit等支持git bash的环境下执行。 以下结合GitHub官方参考指引和相关资料，介绍两种方法: 方法一 使用ssh-agent1. 检查已有的SSH key2. 生成key并加入ssh-agent此处是方法一的关键，度娘上的答案大多只提到怎么生成key，却没有提到要加入ssh-agent，另外在执行ssh-add时遇到 “Could not open a connection to your authentication agent”，查到的解法基本都是执行 $ ssh-agent bash $ ssh-add 然后呢？还是不行，反正我试下来不行，stackoverflow中也中一篇解答给了关键，这在2中也有所体现。 $ eval `ssh-agent -s`问题解决~，查看ssh-agent中的密钥 $ ssh-add -l3. 加到Git账户中不单单适用于GitHub，其他Git仓库也类似 方法二. 在config中配置host第1步、第3步和方法一相同，主要差别在第2步 2. 生成key并配置config文件生成key的方式也和方法一的第2步一样。生成后在~/.ssh 目录下创建config文件，配置私钥对应的服务器，假设为公司GitLab生成的私钥为id_rsa_work，则config文件内容如下： Host gitlab.xxx.com HostName gitlab.xxx.com User git PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_work 第一行的 Host 只是一个名字，第三行的 Hostname 才是对应的真实地址，但是两者最好保持一致，这样后续git链接中的地址就不需要转换。 最后进行SSH连接测试执行以下命令 #测试GitHub以及公司链接 $ ssh -T git@github.com $ ssh -T git@gitlab.xxx.com结果如下： 验证通过后，GitHub的key状态还会发生变化 另外在失败时，可以通过在ssh中加上-v参数，查看具体的处理过程，进行更精确的定位. $ ssh -v -T git@github.com 小结两个方法都能实现多套key的存储，但方法一有个缺陷 ssh-add 这个命令不是用来永久性的记住你所使用的私钥的。实际上，它的作用只是把你指定的私钥添加到 ssh-agent 所管理的一个 session 当中。所以ssh-agent 是一个用于存储私钥的临时性的 session 服务，当你重启之后，ssh-agent 服务也就重置了，不过我们完全可以用脚本自动化这件事，以便启动终端的时候完成。 方法二的操作方式是使用ssh config的配置做定向管理，作用和Mac OS上的Keychain类似，相比方法一，易用性更佳。 P.S. 配置了SSH key之后，一些外部提交方式的提交库的协议方式也应相应调整，如GitExtentions的管理远程代码库、hexo的deploy.repository参数等，都应切换成git@xxx.com:username/repo.git，而不再用https://xxx.com/username/repo.git","categories":[{"name":"技术","slug":"技术","permalink":"http://ajayhao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"git","slug":"git","permalink":"http://ajayhao.github.io/tags/git/"}]},{"title":"ICBC，再见！","slug":"reasons-for-quit","date":"2016-04-23T16:10:00.000Z","updated":"2016-04-23T16:10:00.000Z","comments":true,"path":"2016/04/24/reasons-for-quit/","link":"","permalink":"http://ajayhao.github.io/2016/04/24/reasons-for-quit/","excerpt":"再闪亮的螺丝钉，终究是螺丝钉。","text":"再闪亮的螺丝钉，终究是螺丝钉。 熬是大多数人的宿命，默默忍受着大企业病。 或许能守得云开雾散，毕竟也抛洒了汗水积累了人脉。 此处也有荣誉与褒奖，大多是给予“杂事王”们的补偿。 哪里都有崇高的价值观，这里还需要多少人拿青春埋单。 最终我抬起头迈出这一步，难免一丝遗憾，却收获久违的释然！ so，一图以蔽之。","categories":[{"name":"生活","slug":"生活","permalink":"http://ajayhao.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[]},{"title":"典型Maven化的Web工程","slug":"maven-project","date":"2016-04-12T13:30:00.000Z","updated":"2016-04-12T13:30:00.000Z","comments":true,"path":"2016/04/12/maven-project/","link":"","permalink":"http://ajayhao.github.io/2016/04/12/maven-project/","excerpt":"在处理Web应用的时候，最终使用的工程文件是以War包的形式交付。Maven编译系统可以轻松的创建War包。接下来就让我们看看Maven是如何把一个源文件的工程转换成War包的。","text":"在处理Web应用的时候，最终使用的工程文件是以War包的形式交付。Maven编译系统可以轻松的创建War包。接下来就让我们看看Maven是如何把一个源文件的工程转换成War包的。 一、工程实例非常典型的Maven化的Web工程 对应的POM.xml如下： &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;mygroup.com&lt;/groupId&gt; &lt;artifactId&gt;myprojectname&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;myprojectname Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;myprojectname&lt;/finalName&gt; &lt;/build&gt; &lt;/project&gt;我们用此命令War包 mvn packageWar生成在根目录下 /target/myprojectname.war如下图，概况Maven生成War包过程 二、Maven 默认配置我们都知道Maven可以很容易的把源文件工程创建为War包，但是POM文件中什么也没有设置。这是怎么回事啊？实际上Maven有自己默认的设置。这称之为 “convention over configuration”，Maven在配置中提供默认值。 第一，因为有一些Maven插件本身就与Maven 的生命周期绑定在一起。例如，在编译阶段使用compiler:compile作为默认命令。这就意味着当执行到编译阶段compiler plugin 被调用执行。如果选择生成WAR，那么 war:war 会与这个阶段绑定。 第二，当没有明确设置参数的时候，插件都会有自己默认值。例如 compiler:compile 目标有个参数是 compilerId。当默认值是 javac就意味着JDK 会被使用。当需要生成其他形式时可以重写此配置。 第三，一些设置包含在 Super POM,此文件是POM文件默认继承的。从Maven3 起 Super POM 被放在 maven_dir/lib/maven-model-builder-3.0.3.jar:org/apache/maven/model/pom-4.0.0.xml在这里我们可以发现很多默认的配置信息 &lt;build&gt; &lt;directory&gt;${project.basedir}/target&lt;/directory&gt; &lt;outputDirectory&gt; ${project.build.directory}/classes &lt;/outputDirectory&gt; &lt;finalName&gt; ${project.artifactId}-${project.version} &lt;/finalName&gt; &lt;testOutputDirectory ${project.build.directory}/test-classes &lt;/testOutputDirectory&gt; &lt;sourceDirectory ${project.basedir}/src/main/java &lt;/sourceDirectory&gt; &lt;scriptSourceDirectory&gt; src/main/scripts &lt;/scriptSourceDirectory&gt; &lt;testSourceDirectory&gt; ${project.basedir}/src/test/java &lt;/testSourceDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt; ${project.basedir}/src/main/resources &lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;directory&gt; ${project.basedir}/src/test/resources &lt;/directory&gt; &lt;/testResource&gt; &lt;/testResources&gt; ... &lt;/build&gt;三、Maven 生命周期在我们的工程中，当执行 mvn package 命令，maven会执行它整个生命周期中的六个阶段process-resources, compile, process-test-resources, test-compile, test and package 每个阶段会包含一个或多个目标。Maven 插件提供目标：一个插件可以有一个或多个目标。例如 Compiler 插件有两个目标：compiler:compile 和 compiler:testCompile 所有目标：1.resources:resources此目标用来将资源文件夹下的内容拷贝到输出目录 2.compiler:compile此目标编译源项目工程 3.resources:testResources此目标编译源项目工程 4.compiler:testCompile此目标编译测试项目 5.surefire:test此目标执行工程的单元测试，编译的测试类放在 /target/test-classes 6.war:war此目录创建War包。它会把所有需要的文件放在 /target/myprojectname/而后将他们打包生成 **.war。其中一个步骤是将 /src/main/webapp/拷贝到输出目录。 War插件另外一个重要步骤是拷贝Class文件到到 WEB-INF/classes目录和项目所依赖的jar包到 WEB-INF/lib目录。默认情况下，插件还包含两个Maven描述文件： META-INF/maven/${groupId}/${artifactId}/pom.xml META-INF/maven/${groupId}/${artifactId}/pom.properties 最终的War包放在/target/目录下。 四 、项目依赖pom.xml文件会有一个默认的（JUnit）依赖。我们可以加另外一个常用的Jar - log4j。 &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt; &lt;/dependency&gt;当没有设置依赖范围 （scope），默认为 compile scope。这就意味着此依赖在编译、测试、运行阶段都可以得到。只要是运行中会用到的jar包，都会拷贝到/WEB-INF/lib目录","categories":[{"name":"技术","slug":"技术","permalink":"http://ajayhao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://ajayhao.github.io/tags/maven/"}]},{"title":"git常用操作示例","slug":"git-management","date":"2016-03-31T12:30:00.000Z","updated":"2016-03-31T12:30:00.000Z","comments":true,"path":"2016/03/31/git-management/","link":"","permalink":"http://ajayhao.github.io/2016/03/31/git-management/","excerpt":"摘选自阮一峰的Git分支管理策略 相比同类软件，Git有很多优点。其中很显著的一点，就是版本的分支（branch）和合并（merge）十分方便。有些传统的版本管理软件，分支操作实际上会生成一份现有代码的物理拷贝，而Git只生成一个指向当前版本（又称”快照”）的指针，因此非常快捷易用。","text":"摘选自阮一峰的Git分支管理策略 相比同类软件，Git有很多优点。其中很显著的一点，就是版本的分支（branch）和合并（merge）十分方便。有些传统的版本管理软件，分支操作实际上会生成一份现有代码的物理拷贝，而Git只生成一个指向当前版本（又称”快照”）的指针，因此非常快捷易用。 Vincent Driessen提出了一个分支管理的策略，非常值得借鉴。它可以使得版本库的演进保持简洁，主干清晰，各个分支各司其职、井井有条。理论上，这些策略对所有的版本管理系统都适用。 一、主分支Master首先，代码库应该有一个、且仅有一个主分支。所有提供给用户使用的正式版本，都在这个主分支上发布。Git主分支的名字，默认叫做Master。它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。 二、开发分支Develop主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。这个分支可以用来生成代码的最新隔夜版本（nightly）。如果想正式对外发布，就在Master分支上，对Develop分支进行”合并”（merge）。Git创建Develop分支的命令： git checkout -b develop master将Develop分支发布到Master分支的命令： # 切换到Master分支 git checkout master # 对Develop分支进行合并 git merge --no-ff develop 其中，–no-ff参数是什么意思。默认情况下，Git执行”快进式合并”（fast-farward merge），会直接将Master分支指向Develop分支。 使用–no-ff参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰，我们希望采用这种做法。 三、临时性分支前面讲到版本库的两条主要分支：Master和Develop。前者用于正式发布，后者用于日常开发。其实，常设分支只需要这两条就够了，不需要其他了。但是，除了常设分支以外，还有一些临时性分支，用于应对一些特定目的的版本开发。临时性分支主要有三种： * 功能（feature）分支 * 预发布（release）分支 * 修补bug（fixbug）分支这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有Master和Develop。 1、 功能分支第一种是功能分支，它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop 功能分支的名字，可以采用feature-*的形式命名。 创建一个功能分支： git checkout -b feature-x develop开发完成后，将功能分支合并到develop分支： git checkout develop git merge --no-ff feature-x删除feature分支： git branch -d feature-x2、 预发布分支第二种是预发布分支，它是指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，可以采用release-*的形式。创建一个预发布分支： git checkout -b release-1.2 develop确认没有问题后，合并到master分支： git checkout master git merge --no-ff release-1.2 # 对合并生成的新节点，做一个标签 git tag -a 1.2再合并到develop分支： git checkout develop git merge --no-ff release-1.2最后，删除预发布分支： git branch -d release-1.2 3、 修补bug分支最后一种是修补bug分支。软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-*的形式。 创建一个修补bug分支： git checkout -b fixbug-0.1 master修补结束后，合并到master分支： git checkout master git merge --no-ff fixbug-0.1 git tag -a 0.1.1 再合并到develop分支： git checkout develop git merge --no-ff fixbug-0.1最后，删除”修补bug分支”： git branch -d fixbug-0.1","categories":[{"name":"技术","slug":"技术","permalink":"http://ajayhao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"git","slug":"git","permalink":"http://ajayhao.github.io/tags/git/"}]},{"title":"Markdown语法速查表","slug":"markdown-ref","date":"2016-02-03T13:00:00.000Z","updated":"2016-02-03T13:00:00.000Z","comments":true,"path":"2016/02/03/markdown-ref/","link":"","permalink":"http://ajayhao.github.io/2016/02/03/markdown-ref/","excerpt":"开始写博以后，Markdown会频繁接触，网上已经有了很多参考资料，大多也很全很详细。可惜几乎全是纵排的，类似wiki中表格型排版的很少，可能把这些语法集中表格里也比较费时，所以整理了张简便易用的速查表格,供参考。","text":"开始写博以后，Markdown会频繁接触，网上已经有了很多参考资料，大多也很全很详细。可惜几乎全是纵排的，类似wiki中表格型排版的很少，可能把这些语法集中表格里也比较费时，所以整理了张简便易用的速查表格,供参考。 Markdown语法对应Html浏览器效果一级标题(Setext格式,只支持到二级)=======&lt;h1&gt;一级标题 &lt;/h1&gt;一级标题二级标题\\-\\-\\-\\-\\-\\-&lt;h2&gt;二级标题 &lt;/h2&gt;二级标题### 三级标题(atx格式,最低到六级)&lt;h3&gt; 三级标题 &lt;/h3&gt;三级标题 换行：行尾留2个空格&lt;p&gt;换行：行尾留2个&lt;br /&gt;空格&lt;/p&gt; 换行：行尾留2个空格\\*斜体\\*&lt;em&gt;斜体&lt;/em&gt;斜体\\*\\*粗体\\*\\*&lt;strong&gt;粗体&lt;/strong&gt;粗体\\`标注\\`&lt;code&gt;标注&lt;/code&gt;标注\\~\\~删除线\\~\\~&lt;s&gt;删除线&lt;/s&gt;删除线长连接\\-\\-\\-线长连接&amp;mdash;线长连接&mdash;线行首留4个空格，此行变为代码块&lt;pre&gt;&lt;code&gt;代码块&lt;/code&gt;&lt;/pre&gt;代码块链接:\\[链接\\]\\(http://example\\.com\\)&lt;a href=&quot;http://example.com &quot;&gt;链接 &lt;/a&gt;链接图片:暂不支持宽高设置\\!\\[Alt text\\]\\(/path/to/img\\.jpg \"title optional\"\\) &lt;img alt=&quot;Alt text&quot; src=&quot;path&quot; title=&quot;title&quot; /&gt;&gt;在段落的最前方加大于号引用区块&lt;blockquote&gt;引用内容&lt;/blockquote&gt;引用内容无序列表：星号、加号或是减号均可,中间留空格\\* 条目1\\* 条目2\\* 条目3&lt;ul&gt;&lt;li&gt;条目1&lt;/li&gt;&lt;li&gt;条目2&lt;/li&gt;&lt;li&gt;条目3&lt;/li&gt;&lt;/ul&gt;条目1条目2条目3有序列表：数字开头,中间留空格1\\. 条目12\\. 条目23\\. 条目3&lt;ol&gt;&lt;li&gt;条目1&lt;/li&gt;&lt;li&gt;条目2&lt;/li&gt;&lt;li&gt;条目3&lt;/li&gt;&lt;/ol&gt;条目1条目2条目3分隔线:一行中仅包含三个以上的星号、减号、底线&lt;hr&gt; 最后以下符号在Markdown中需要在前面加上反斜杠转义 \\ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号","categories":[{"name":"技术","slug":"技术","permalink":"http://ajayhao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://ajayhao.github.io/tags/markdown/"}]},{"title":"启航","slug":"virgin-post","date":"2016-01-18T13:30:00.000Z","updated":"2016-01-18T13:30:00.000Z","comments":true,"path":"2016/01/18/virgin-post/","link":"","permalink":"http://ajayhao.github.io/2016/01/18/virgin-post/","excerpt":"倒腾了一个周末，算是把个人博客搭起来了，此篇虽取名“启航”，却也不算日志处子贴，记得博客最火那阵子我还在象牙塔里，玩qqzone，玩msn空间，虽然post不多，却也是满满的回忆。","text":"倒腾了一个周末，算是把个人博客搭起来了，此篇虽取名“启航”，却也不算日志处子贴，记得博客最火那阵子我还在象牙塔里，玩qqzone，玩msn空间，虽然post不多，却也是满满的回忆。 后来众所周知的原因，msn空间关闭了，身边好友有的转战blogbus、cnblog，有的开始注册独立域名，搭建自己的博客，好歹也都还有自己的一片空间。那还是WP如日中天的年代，也曾想在那儿寻个寄宿点，无奈每每懒癌发作，半途而废，很多事一松懈就黄了，一晃(黄)又是好几年。 在金融行业做了好些年it技术，虽是技能点乱点各种不伦不类，还算存着一颗技术出身的心性。本意是弄一个个人网站，可以玩一玩各种新技术，无奈空间流量都太贵，而后受cnfeat启发，在Github Page上搭建起blog，一脚跨进Hexo的大门，在此不得不吐槽下阿里云，开价实在有些不厚道。。Github Page有300M空间，无限流量，让身在大天朝寒冬中的我倍感暖意。。blog先运作起来，Django的个人空间只好再去找窝，话说为了媳妇儿的账本（记账功能），还得开个local的mysql实例，算了说多了都是泪TT 为什么要在GitHub上搭建自己的空间？穷呗。。除此之外么。。可以折腾^^ 如果你也想有个属于自己的博客空间，却只是因为无法说服自己下这个决心折腾一把~， 安利一些过来人经验: cnFeat : 如何搭建一个独立博客——简明Github Pages与Hexo教程 Xuanwo : Hexo常见问题解决方案 chitanda : hexo博客搭建时遇到的一些问题","categories":[{"name":"生活","slug":"生活","permalink":"http://ajayhao.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://ajayhao.github.io/tags/%E6%9D%82%E8%B0%88/"}]}],"categories":[{"name":"技术","slug":"技术","permalink":"http://ajayhao.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"生活","slug":"生活","permalink":"http://ajayhao.github.io/categories/%E7%94%9F%E6%B4%BB/"},{"name":"金融业务","slug":"金融业务","permalink":"http://ajayhao.github.io/categories/%E9%87%91%E8%9E%8D%E4%B8%9A%E5%8A%A1/"}],"tags":[{"name":"https","slug":"https","permalink":"http://ajayhao.github.io/tags/https/"},{"name":"python","slug":"python","permalink":"http://ajayhao.github.io/tags/python/"},{"name":"杂谈","slug":"杂谈","permalink":"http://ajayhao.github.io/tags/%E6%9D%82%E8%B0%88/"},{"name":"其他","slug":"其他","permalink":"http://ajayhao.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"金融","slug":"金融","permalink":"http://ajayhao.github.io/tags/%E9%87%91%E8%9E%8D/"},{"name":"工具","slug":"工具","permalink":"http://ajayhao.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Java","slug":"Java","permalink":"http://ajayhao.github.io/tags/Java/"},{"name":"大数据","slug":"大数据","permalink":"http://ajayhao.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"可视化","slug":"可视化","permalink":"http://ajayhao.github.io/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"echarts","slug":"echarts","permalink":"http://ajayhao.github.io/tags/echarts/"},{"name":"django","slug":"django","permalink":"http://ajayhao.github.io/tags/django/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://ajayhao.github.io/tags/Mybatis/"},{"name":"多线程","slug":"多线程","permalink":"http://ajayhao.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"TA","slug":"TA","permalink":"http://ajayhao.github.io/tags/TA/"},{"name":"基金业务","slug":"基金业务","permalink":"http://ajayhao.github.io/tags/%E5%9F%BA%E9%87%91%E4%B8%9A%E5%8A%A1/"},{"name":"会计核算","slug":"会计核算","permalink":"http://ajayhao.github.io/tags/%E4%BC%9A%E8%AE%A1%E6%A0%B8%E7%AE%97/"},{"name":"J2EE","slug":"J2EE","permalink":"http://ajayhao.github.io/tags/J2EE/"},{"name":"git","slug":"git","permalink":"http://ajayhao.github.io/tags/git/"},{"name":"maven","slug":"maven","permalink":"http://ajayhao.github.io/tags/maven/"},{"name":"markdown","slug":"markdown","permalink":"http://ajayhao.github.io/tags/markdown/"}]}